: # use perl -*-Perl-*-
eval 'exec perl -S "$0" ${1+"$@"}'
    if 0;
# -*cperl-*-

use strict;
use Getopt::Long;
use File::Basename;
# File::Temp is a library for creating temporary files.
use File::Temp qw/ tempfile tempdir /;
use File::Copy;
# FindBin is a library to find the directory in which the script is
# installed.  This can be useful for making it easy to install other
# auxiliary files needed by the script all in one place, and no matter
# where someone installs 'the whole package' of files, the script can
# find them, without needing hand-editing.
use FindBin;
use IPC::Open3;
use Symbol qw(gensym);
use IO::File;
use Math::BigInt;
use XML::LibXML;
use Cwd;


my $verbose = 0;
my $full_progname = $0;
my $progname = fileparse($full_progname);
my $save_dir_name;

my $os = `uname -o 2>/dev/null`;
if ($? != 0) {
    # Then likely we are running on a Mac OS X system with the default
    # uname installation, which accepts -s but not -o option.
    $os = `uname -s 2>/dev/null`;
}
chomp $os;
my $os_full = `uname -a`;
chomp $os_full;
my $cwd = cwd();

my $install_dir = $FindBin::Bin;
my $timemem_cmd = time_cmd_location($os, $install_dir);
my $sumgclog_cmd = sumgclog_location($os, $install_dir);


sub usage {
    print STDERR
"usage: $progname [ --help ] [ --verbose ]
               [ --xml ]
               [ --log-file <log_file> ]
               [ --input-file <input_file> ]
               [ --output-file <output_file> ]
               [ --check-output-cmd <check_output_cmd> ]
               [ --os <os_name> ]
               [ --time-cmd <time_cmd> ]
               [ --language <language_implementation_description_string> ]
               [ --benchmark <benchmark_problem_name> ]
               [ --source-file-name <source_file_name> ]
               [ --jvm-info { client | server } ]
               [ --jvm-cmd <jvm_command> ]
               [ --jvm-gc-stats <jvm_type> ]
               [ --jruby-gc-stats <jvm_type> ]
               [ --save-temp-files ]
               [ --never-save-temp-files ]
               <measured_cmd> [ arg1 ... ]

    --help        Show this help.

    --verbose     Enable debug messages.

    --xml         Print measurement output in XML format.

    --log-file <log_file>
                  Append measurement output to file <log_file>,
                  creating <log_file> if it does not exist already.
                  If --xml is specified, the XML structure of the
                  existing measurements in that file is preserved, and
                  the new measurement is appended to the end.  If
                  --xml is not specified, the results are simply
                  appended to the end of the file.

    --input-file <input_file>
                  Input file for <measured_cmd> (optional).  If
                  provided, <measured_cmd> will be invoked with its
                  standard input redirected from <input_file>.

    --output-file <output_file>
                  Similar to --input-file, except it is a file name
                  where <measure_cmd>'s standard output will be
                  redirected into, if provided.

    --check-output-cmd <check_output_cmd>
                  A command string used to check whether the output
                  file's contents are good.  The command's exit status
                  should be 0 (i.e. no error) if the output is good,
                  or any non-zero value if the output is not good.

                  This command string may have occurences of %o in it.
                  If so, $progname will replace all such occurrences
                  with the output file name.  This option should only
                  be given if --output-file is also given.

    --os <os_name>
                  Can be used to specify one of the supported OSs:
                      Cygwin
                      Darwin
                      GNU/Linux
                  This command line option need only be used to
                  override the default of '$os', which is detected via
                  the output of the 'uname -o' command.

    --time-cmd <time_cmd>
                  Specify the command to use to measure the running
                  time and memory usage of the process.  This is only
                  needed if you wish to override the default command,
                  which for platform '$os' is: $timemem_cmd

    --jvm-info { client | server }
    --jvm-cmd <jvm_command>
                  When this option is used, $progname will run a small
                  compiled Java program JVMInfo.class that should be
                  installed in the same directory as $progname, before
                  running <measured_cmd>.  This program will print
                  some information such as the host OS, JVM version,
                  and number of available processors, among other
                  things, and $progname will collect this and include
                  it in the output.

                  Likely most of this information will be the same
                  regardless of whether a -client or -server command
                  line option is used, but in case they are different,
                  you must specify which to use by the string that
                  appears after --jvm-info on the command line.

                  If the --jvm-cmd option is specified, $progname will
                  use that as the command to use when invoking the JVM
                  to execute JVMInfo.class.  If no --jvm-cmd option is
                  specified, $progname wil use the first 'word' of
                  <measured_cmd> as the name of the command to invoke
                  the JVM.

                  (TBD: This should be tested with path names that
                  have spaces in them to see whether it works in that
                  case or not).

    --jvm-gc-stats <jvm_type>
                  When this option is used, $progname will assume that
                  <measured_cmd> is an invocation of a Java virtual
                  machine that takes an additional command line option
                  in order to report information about garbage
                  collection (GC) invocation.  What the option is
                  depends upon what kind of JVM is in use.  The
                  following are supported by $progname:

                    --jvm-gc-stats hotspot
                        -Xloggc:<gc_log_file>
                    --jvm-gc-stats jrockit
                        -Xverbose:memory -Xverboselog:<gc_log_file>

                  $progname will modify the command line given to add
                  options like the ones above, with the name of an
                  auto-generated temporary file name, and then parse
                  the contents of this file when <measured_cmd> exits.
                  Some summary statistics about the contents will be
                  reported.

    --jruby-gc-stats <jvm_type>
                  This is the same as --jvm-gc-stats, except that the
                  command line option added to the command line will
                  have a '-J' prepended to it, as required by the
                  jruby command in order to pass the options through
                  to the JVM invocation.

    --save-temp-files
    --never-save-temp-files
                  Without either of these options, $progname will
                  generate several temporary files that are usually
                  deleted upon completion.

                  If there are errors in parsing the GC log file, it
                  will be saved in a file that is not deleted.  The
                  name of this file will be included in the output.

                  If the --check-output-cmd is given, and has a
                  non-zero exit status, indicating the output file is
                  not good, then a copy of the output file will be
                  made in a new temp directory, and not deleted, even
                  if many consecutive runs of measureproc are made
                  with the same output file name.  The name of this
                  new file will be included in the output.

                  With the option --save-temp-files, these files will
                  be saved even if there are no errors / the output
                  file is checked as good.

                  With the option --never-save-temp-files, these files
                  will not be saved, even if there are parse errors,
                  or the output file is checked as bad.

    The options below do not affect how the command is run or its
    performance measured.  They are simply printed to the output for
    inclusion in whatever results the user wishes to collect.  They
    could be useful later for keeping track of which results are
    which.

    --language <language_implementation_description_string>
    --benchmark <benchmark_problem_name>
    --source-file-name <source_file_name>

Note that command line options can be abbreviated to the shortest
prefix that uniquely identifies them.

Example of use on Linux or Mac OS X:

  % $progname --input input/medium-input.txt --output output/medium-clj-1.2-output.txt java -version
  [ ... output removed ... ]

  % $progname --input input/medium-input.txt --output output/medium-clj-1.2-output.txt java -server -Xmx1536m -classpath ~/lein/swank-clj-1.2.0/lib/clojure-1.2.0.jar:./obj/clj-1.2 knucleotide
  [ ... output removed ... ]

  % $progname --input input/quick-input.txt --output output/quick-clj-1.2-output.txt --check 'diff --strip-trailing-cr --brief output/quick-expected-output.txt %o' java -server -Xmx1536m -classpath ~/lein/swank-clj-1.2.0/lib/clojure-1.2.0.jar:./obj/clj-1.2 knucleotide
      Command measured          : java -server -Xmx1536m -classpath /Users/andy/lein/swank-clj-1.2.0/lib/clojure-1.2.0.jar:./obj/clj-1.2 knucleotide
      Elapsed time (sec)        : 2.857
      User CPU time (sec)       : 3.107
      System CPU time (sec)     : 0.302
      Max resident set size (kb): 80992
      Start time                : Wed Nov 10 18:55:06 2010
      End time                  : Wed Nov 10 18:55:08 2010
      Per core CPU usage (2 cores): 92% 90%
      Exit status               : 0
      Command to check output   : diff --strip-trailing-cr --brief output/quick-expected-output.txt output/quick-clj-1.2-output.txt
      Exit status of check cmd  : 0
      OS description            : Darwin andys-mbp.local 9.8.0 Darwin Kernel Version 9.8.0: Wed Jul 15 16:55:01 PDT 2009; root:xnu-1228.15.4~1/RELEASE_I386 i386 i386 MacBookPro4,1 Darwin

Examples of use on Windows XP + Cygwin:

  % $progname --input input\\\\medium-input.txt --output output\\\\medium-clj-1.2-output.txt \\\\Program\\ Files\\\\Java\\\\jrmc-4.0.1-1.6.0\\\\bin\\\\java -version
  [ ... output removed ... ]

  % $progname --verbose --input input\\\\quick-input.txt --output output\\\\quick-clj-1.2-output.txt \\\\Program\\ Files\\\\Java\\\\jrmc-4.0.1-1.6.0\\\\bin\\\\java -server -Xmx1536m -classpath \"\\\\cygwin\\\\home\\\\Admin\\\\lein\\\\swank-clj-1.2.0\\\\lib\\\\clojure-1.2.0.jar;.\\\\obj\\\\clj-1.2\" knucleotide
  [ ... output removed ... ]
";
}

######################################################################
# Get command line options
######################################################################

my $help;
my $output_format_xml;
my $log_file;
my $input_file;
my $output_file;
my $check_output_cmd;
my $os_from_cmd_line;
my $time_cmd_from_cmd_line;
my $jvm_info;
my $jvm_cmd;
my $jvm_gc_stats_from_cmd_line;
my $jruby_gc_stats_from_cmd_line;
my $save_temp_files;
my $never_save_temp_files;
my $language_implementation_desc_str = '';
my $benchmark_name = '';
my $source_file_name = '';
Getopt::Long::Configure('require_order');
if (!GetOptions('help' => \$help,
		'verbose' => \$verbose,
		'xml' => \$output_format_xml,
		'log-file=s' => \$log_file,
		'input-file=s' => \$input_file,
		'output-file=s' => \$output_file,
		'check-output-cmd=s' => \$check_output_cmd,
		'os=s' => \$os_from_cmd_line,
		'time-cmd=s' => \$time_cmd_from_cmd_line,
                'jvm-info=s' => \$jvm_info,
                'jvm-cmd=s' => \$jvm_cmd,
                'jvm-gc-stats=s' => \$jvm_gc_stats_from_cmd_line,
                'jruby-gc-stats=s' => \$jruby_gc_stats_from_cmd_line,
                'save-temp-files' => \$save_temp_files,
                'never-save-temp-files' => \$never_save_temp_files,
		'language=s' => \$language_implementation_desc_str,
		'benchmark=s' => \$benchmark_name,
		'source-file-name=s' => \$source_file_name
               ))
{
    usage();
    exit(1);
}

$os = $os_from_cmd_line if (defined($os_from_cmd_line));
if ($verbose) {
    printf STDERR "\$os='%s'\n", $os;
    printf STDERR "install dir='%s'\n", $FindBin::Bin;
}
if ($help) {
    usage();
    exit(0);
}
if (defined($save_temp_files) && defined($never_save_temp_files)) {
    printf STDERR
"At most one of --save-temp-files and --never-save-temp-files should
be specified.
",;
    exit 1;
}
if (defined($jvm_info)) {
    if (! (($jvm_info eq 'client') || ($jvm_info eq 'server')) ) {
	printf STDERR
"The value after --jvm-info must be 'client' or 'server'.  Found '%s'.
", $jvm_info;
	exit 1;
    }
}
my $gc_stats_type;
my $gc_stats_jruby;
if (defined($jvm_gc_stats_from_cmd_line) &&
    defined($jruby_gc_stats_from_cmd_line))
{
    printf STDERR
"At most one of --jvm-gc-stats and --jruby-gc-stats should be
specified, depending on whether the measured command is a jruby
invocation or a java invocation.
";
    exit 1;
}
if (defined($jruby_gc_stats_from_cmd_line)) {
    $gc_stats_type = $jruby_gc_stats_from_cmd_line;
    $gc_stats_jruby = 1;
} elsif (defined($jvm_gc_stats_from_cmd_line)) {
    $gc_stats_type = $jvm_gc_stats_from_cmd_line;
    $gc_stats_jruby = 0;
}
if (defined($gc_stats_type)) {
    if ($gc_stats_type eq 'hotspot') {
        # OK
    } elsif ($gc_stats_type eq 'jrockit') {
        # OK
    } else {
        printf STDERR
"Unrecognized value '%s' given after option %s
The following are supported: hotspot jrockit
",
            $gc_stats_type,
            ($gc_stats_jruby ? '--jruby-gc-stats' : '--jvm-gc-stats');
        exit 1;
    }
}
$timemem_cmd = (defined($time_cmd_from_cmd_line) ? $time_cmd_from_cmd_line
		: time_cmd_location($os, $install_dir));
if ($timemem_cmd =~ /^(\S+)/) {
    my $cmd = $1;
    if (! -x $cmd) {
	die sprintf "There is no command '$cmd' to measure performance for your command\n";
    }
}
if ($#ARGV < 0) {
    printf STDERR "No command given.\n";
    usage();
    exit 1;
}

my $tempdir;
if (($os eq 'Cygwin') || defined($gc_stats_type)) {
    # We will later use a temporary directory for creating one or more
    # temporary files.
    $tempdir = tempdir( CLEANUP => 1 );
}

######################################################################
# Construct command to run (and measure its performance)
######################################################################

my $gc_log_filename;
my $cmd_first_word = shift @ARGV;
if ($os eq 'Cygwin') {
    # timemem.exe expects a DOS/Windows file name for the command, but
    # when writing shell scripts that we want to work on both
    # Windows+Cygwin and Linux/Mac OS X, it is sometimes inconvenient
    # to make a separate case for such things.

    # Let cygpath -w convert it to DOS/Windows if it is not.  If it
    # already is, cygpath -w seems to recognize this and leave it
    # alone.
    $cmd_first_word = `cygpath -w "$cmd_first_word"`;
    chomp $cmd_first_word;
}
my $cmd_to_time = $cmd_first_word;
if (defined($gc_stats_type)) {
    my $tempfh;
    ($tempfh, $gc_log_filename) = tempfile( DIR => $tempdir,
					    SUFFIX => '.txt' );
    my $log_fname = $gc_log_filename;
    if ($os eq 'Cygwin') {
	$log_fname = `cygpath -w $gc_log_filename`;
	chomp $log_fname;
    }
    my $prefix = ($gc_stats_jruby ? '-J' : '');
    if ($gc_stats_type eq 'hotspot') {
        $cmd_to_time .= (sprintf ' %s-Xloggc:%s', $prefix, $log_fname);
    } elsif ($gc_stats_type eq 'jrockit') {
        $cmd_to_time .= (sprintf ' %s-Xverbose:memory %s-Xverboselog:%s',
                             $prefix, $prefix, $log_fname);
    }
}
$cmd_to_time .= (' ' . join(' ', @ARGV));

if ($verbose) {
    printf STDERR "\$cmd_to_time='%s'\n", $cmd_to_time;
}

my $cmd_str = '';
my $cmd_begin = '';
my $cmd_end = '';
if ($os eq 'Cygwin') {
    $cmd_begin = '"';
    $cmd_end = '"';
}
$cmd_str .= sprintf "%s %s%s%s", $timemem_cmd, $cmd_begin, $cmd_to_time, $cmd_end;
if (defined($input_file)) {
    $cmd_str .= sprintf " < %s", $input_file;
}
if (defined($output_file)) {
    $cmd_str .= sprintf " > %s", $output_file;
}
if ($verbose) {
    printf STDERR "\$cmd_str='%s'\n", $cmd_str;
}

my $cmd_to_run;
if ($os eq 'Cygwin') {
    # On Cygwin, put the command into a BAT file for execution.
    my ($fh, $batchfile) = tempfile( DIR => $tempdir, SUFFIX => '.bat' );
    if ($verbose) {
	printf STDERR "\$tempdir='%s'\n", $tempdir;
    }
    printf $fh "%s\n", $cmd_str;
    close $fh;
    chmod 0755, $batchfile;
    $cmd_to_run = $batchfile;

    if ($save_temp_files) {
	my ($copy_succeeded, $copy_info, $batch_copy_filename);
	($save_dir_name, $copy_succeeded, $copy_info, $batch_copy_filename) =
	    save_copy_of_file($save_dir_name, $batchfile,
			      'batch file', 'bat-file');
	printf STDERR "%s", $copy_info;
    }
} else {
    $cmd_to_run = $cmd_str;
}
if ($verbose) {
    printf STDERR "\$cmd_to_run='%s'\n", $cmd_to_run;
}


######################################################################
# If requested, run the JVM to get some information about it and the
# host machine and OS.
######################################################################

my $jvm_property_names = [
    'os.arch',
    'availableProcessors',
    'os.name',
    'os.version',
    'java.version',
    'java.specification.version',
    'java.vm.name',
    'java.vm.version',
    'java.runtime.version',
    'sun.arch.data.model' ];
my $jvm_property_xml_tags = {
    'os.arch' => 'jvm_os_arch',
    'availableProcessors' => 'jvm_availableProcessors',
    'os.name' => 'jvm_os_name',
    'os.version' => 'jvm_os_version',
    'java.version' => 'jvm_java_version',
    'java.specification.version' => 'jvm_java_specification_version',
    'java.vm.name' => 'jvm_java_vm_name',
    'java.vm.version' => 'jvm_java_vm_version',
    'java.runtime.version' => 'jvm_java_runtime_version',
    'sun.arch.data.model' => 'jvm_sun_arch_data_model'
};

my $jvm_info_hash;
if (defined($jvm_info)) {
    if (!defined($jvm_cmd)) {
	$jvm_cmd = $cmd_first_word;
    }
    my $jvm_cmd_to_use = $jvm_cmd;
    if ($os eq 'Cygwin') {
	$jvm_cmd_to_use = `cygpath -u "$jvm_cmd"`;
	chomp $jvm_cmd_to_use;
    }
    my $jvm_cmd_list = [ $jvm_cmd_to_use ];
    my $install_dir_to_use = $install_dir;
    if ($os eq 'Cygwin') {
	$install_dir_to_use = `cygpath -w "$install_dir"`;
	chomp $install_dir_to_use;
    }
    push @{$jvm_cmd_list}, ('-' . $jvm_info),
        '-classpath', $install_dir_to_use, 'JVMInfo';
    my $jvm_cmd_string = join(' ', @{$jvm_cmd_list});
    open (JVM_OUT, '-|', @{$jvm_cmd_list})
	or die sprintf "Could not execute command '%s' and read its output.\n",
	    $jvm_cmd_string;
    my $line;
    $jvm_info_hash->{'jvm_info_full_cmd'} = $jvm_cmd_string;
    while ($line = <JVM_OUT>) {
	if ($line =~ /^([^=]+)=(.*)$/) {
	    my ($property, $val) = ($1, $2);
	    if (defined($jvm_property_xml_tags->{$property})) {
		$jvm_info_hash->{$property} = $val;
	    } else {
		die sprintf
"Unrecognized property name '%s' in output line from command '%s':\n%s",
	            $property, $jvm_cmd_string, $line;
	    }
	} else {
	    die sprintf "Unrecognized output line from command '%s':\n%s",
	        $jvm_cmd_string, $line;
	}
    }
    close(JVM_OUT);
}


######################################################################
# Run the command, and read performance stats from its standard error
# output.
######################################################################

my ($elapsed_sec, $user_sec, $sys_sec, $max_rss_kbytes);
my $num_cpus;
my $usage_per_cpu = 'not calculated';
my ($per_cpu_stats_start, $total_cpu_stats_start);
my ($per_cpu_stats_end, $total_cpu_stats_end);

# I want to run the program and read its stderr output.  I'll assume
# that stdout is already being saved to a file, and ignore anything
# that goes to stdout.

# This is a slight modification of some sample code I found at:
# http://perldoc.perl.org/perlfaq8.html#How-can-I-capture-STDERR-from-an-external-command?

local *CATCHERR = IO::File->new_tmpfile;
if (($os eq 'GNU/Linux') || ($os eq 'Cygwin')) {
    ($per_cpu_stats_start, $total_cpu_stats_start) = linux_get_cpu_usage();
}
my $start_time = localtime();
my $pid = open3(gensym, \*CATCHOUT, ">&CATCHERR", $cmd_to_run);
while (<CATCHOUT>) {
}
waitpid($pid, 0);
my $child_exit_status = $? >> 8;
my $end_time = localtime();
if (($os eq 'GNU/Linux') || ($os eq 'Cygwin')) {
    ($per_cpu_stats_end, $total_cpu_stats_end) = linux_get_cpu_usage();
}
seek CATCHERR, 0, 0;

my $cmd_exit_status;
my $unrecognized_cmd_stderr_output = '';
if ($os eq 'Cygwin') {
    my $found_pid = 0;
    while (<CATCHERR>) {
	chomp;
	s/\r$//;
	if (/^Process ID/) {
	    $found_pid = 1;
        } elsif (/^\s*Dumping CPU usage by sampling running threads \.\.\. done\.\s*$/) {
            # Ignore this line if JVM profiling via sampling was
            # enabled.
	} elsif ($found_pid) {
	    if (/^\s+exit code: (.*)\s*$/) {
		$cmd_exit_status = $1;
	    } elsif (/^\s+elapsed time \(seconds\): (.*)\s*$/) {
		$elapsed_sec = $1;
	    } elsif (/^\s+user time \(seconds\): (.*)\s*$/) {
		$user_sec = $1;
	    } elsif (/^\s+kernel time \(seconds\): (.*)\s*$/) {
		$sys_sec = $1;
	    } elsif (/^\s+Peak Working Set Size \(kbytes\): (\d+)\s*$/) {
		$max_rss_kbytes = $1;
	    } elsif (/^\s+Page Fault Count: (\d+)\s*$/) {
		# Ignore this and the ones immediately below
	    } elsif (/^\s+Quota Peak Paged Pool Usage: (\d+)\s*$/) {
	    } elsif (/^\s+Quota Peak Non Paged Pool Usage: (\d+)\s*$/) {
	    } elsif (/^\s+Peak Pagefile Usage: (\d+)\s*$/) {
	    } else {
		if (! /^\s*$/) {
		    $unrecognized_cmd_stderr_output .= ($_ . "\n");
		}
	    }
	} else {
	    # This is a line of output from the program, most likely
	    # one printed to stderr if stdout has been redirected.
	    if (! /^\s*$/) {
		$unrecognized_cmd_stderr_output .= ($_ . "\n");
	    }
	}
    }
} elsif ($os eq 'Darwin') {
    $cmd_exit_status = $child_exit_status;
    my $found_real = 0;
    if ($verbose) {
	printf STDERR "Reading stderr output of command: %s\n", $cmd_to_run;
    }
    while (<CATCHERR>) {
	chomp;
	if ($verbose) {
	    printf STDERR "stderr line: %s\n", $_;
	}
	if (/^\s*real\s+(.*)\s*$/) {
	    $elapsed_sec = $1;
	    $found_real = 1;
	} elsif (/^\s*Dumping CPU usage by sampling running threads \.\.\. done\.\s*$/) {
	    # Ignore this line if JVM profiling via sampling was
	    # enabled.
        } elsif (/^\s*Shared archive: sharing disabled for server vm\s*$/) {
	    # This line is often printed on my PowerPC-based Mac
            # by the JVM.
	} elsif ($found_real) {
	    if (/^\s*user\s+(.*)\s*$/) {
		$user_sec = $1;
	    } elsif (/^\s*sys\s+(.*)\s*$/) {
		$sys_sec = $1;
	    } elsif (/^\s*(\d+)\s+maximum resident set size from (getrusage|polling).*\s*$/)
	    {
		# Mac OS X 10.5.* reports max RSS from getrusage in
		# units of bytes.  Convert to kbytes.  Use BigInt
		# arithmetic, in case the integer is very large.

		# Mac OS X 10.6.* always reports 0 for max RSS from
		# getrusage, so the measurement obtained from periodic
		# polling of the current resident set size should be
		# used.
		my $max_rss_kbytes_bi = Math::BigInt->new($1);
		my $measurement_type = $2;
		# Add 1023 before dividing (with truncation) by 1024,
		# so that the net effect is to round the number of
		# bytes up to the next whole number of kbytes.
		$max_rss_kbytes_bi->badd(1023);
		$max_rss_kbytes_bi->bdiv(1024);
		$max_rss_kbytes = sprintf "%s", $max_rss_kbytes_bi;
	    } elsif (/^\s*Per core CPU utilization \((\d+) cores\): (.*)$/) {
		($num_cpus, $usage_per_cpu) = ($1, $2);
	    } elsif (
		/^\s*number of times rss polled=\d+, avg of \d+(\.\d+)? times per second\s*$/ ||
		/^\s*time between consecutive polls \(msec\): min=\d+(\.\d+)? max=\d+(\.\d+)?\s*$/ ||
		/^\s*Max RSS observed \d+(\.\d+)? sec after start time\s*$/ ||
		/^\s*A call to task_info\(\) returned an error\.  error_time - end_time = -?\d+(\.\d+)? sec\.  This may mean the maximum resident set size measurement above is too low\.\s*$/)
	    {
		# Ignore these lines, but don't treat them as
		# unrecognized lines.
	    } else {
		if (! /^\s*$/) {
		    $unrecognized_cmd_stderr_output .= ($_ . "\n");
		}
	    }
	} else {
	    # This is a line of output from the program, most likely
	    # one printed to stderr if stdout has been redirected.
	    if (! /^\s*$/) {
		$unrecognized_cmd_stderr_output .= ($_ . "\n");
	    }
	}
    }
} elsif ($os eq 'GNU/Linux') {
    $cmd_exit_status = $child_exit_status;
    my $found_user = 0;
    while (<CATCHERR>) {
	chomp;
	if (/^\s*User time \(seconds\):\s*(.*)\s*$/) {
	    $user_sec = $1;
	    $found_user = 1;
        } elsif (/^\s*Command being timed:.*$/ ||
                 /^\s*Percent of CPU this job got: \d+%\s*$/ ||
                 /^\s*Average shared text size \(kbytes\): \d+\s*$/ ||
                 /^\s*Average unshared data size \(kbytes\): \d+\s*$/ ||
                 /^\s*Average stack size \(kbytes\): \d+\s*$/ ||
                 /^\s*Average total size \(kbytes\): \d+\s*$/ ||
                 /^\s*Average resident set size \(kbytes\): \d+\s*$/ ||
                 /^\s*Major \(requiring I\/O\) page faults: \d+\s*$/ ||
                 /^\s*Minor \(reclaiming a frame\) page faults: \d+\s*$/ ||
                 /^\s*Voluntary context switches: \d+\s*$/ ||
                 /^\s*Involuntary context switches: \d+\s*$/ ||
                 /^\s*Swaps: \d+\s*$/ ||
                 /^\s*File system inputs: \d+\s*$/ ||
                 /^\s*File system outputs: \d+\s*$/ ||
                 /^\s*Socket messages sent: \d+\s*$/ ||
                 /^\s*Socket messages received: \d+\s*$/ ||
                 /^\s*Signals delivered: \d+\s*$/ ||
                 /^\s*Page size \(bytes\): \d+\s*$/ ||
                 /^\s*Exit status: \d+\s*$/
                )
        {
            # Ignore these lines, but don't treat them as unrecognized
            # lines.
	} elsif (/^\s*Dumping CPU usage by sampling running threads \.\.\. done\.\s*$/) {
	    # Ignore this line if JVM profiling via sampling was
	    # enabled.
	} elsif ($found_user) {
            if (/^\s*System time \(seconds\):\s*(.*)\s*$/) {
		$sys_sec = $1;
            } elsif (/^\s*Elapsed \(wall clock\) time \(h:mm:ss or m:ss\):\s*(.*)\s*$/) {
                my $tmp = $1;
                if ($tmp =~ /^(\d+):(\d+):(\d+(\.\d+)?)$/) {
                    my ($h, $m, $s) = ($1, $2, $3);
                    $elapsed_sec = $h * 3600 + $m * 60 + $s;
                } elsif ($tmp =~ /^(\d+):(\d+(\.\d+)?)$/) {
                    my ($m, $s) = ($1, $2);
                    $elapsed_sec = $m * 60 + $s;
                } else {
                    die sprintf "Unrecognized Elapsed (wall clock) time format seen.  Aborting:\n%s", $tmp;
                }
	    } elsif (/^\s*Maximum resident set size \(kbytes\):\s*(\d+)\s*$/) {
                # There is a bug in GNU time version 1.7 that causes
                # the maximum resident set size reported to be 4 times
                # too large, at least when running on Linux.  See:
		#
                # http://www.mail-archive.com/help-gnu-utils@gnu.org/msg01371.html
		#
		# You can find out which version of GNU time you have
		# using this command:
		#
                #     /usr/bin/time -V

		# Use BigInt arithmetic, in case the integer is very
		# large.
		my $max_rss_kbytes_bi = Math::BigInt->new($1);
		$max_rss_kbytes_bi->bdiv(4);
		$max_rss_kbytes = sprintf "%s", $max_rss_kbytes_bi;
	    } else {
		if (! /^\s*$/) {
		    $unrecognized_cmd_stderr_output .= ($_ . "\n");
		}
	    }
	} else {
	    # This is a line of output from the program, most likely
	    # one printed to stderr if stdout has been redirected.
	    if (! /^\s*$/) {
		$unrecognized_cmd_stderr_output .= ($_ . "\n");
	    }
	}
    }
}
close(F);
if (($os eq 'GNU/Linux') || ($os eq 'Cygwin')) {
   $num_cpus = $#{$per_cpu_stats_start} + 1;
   if ($verbose) {
       printf STDERR "\$num_cpus=%s\n", $num_cpus;
   }
   $usage_per_cpu = '';
   my $i;
   for ($i = 0; $i < $num_cpus; $i++) {
       my $cpu_busy_percent =
	   cpu_busy_percent($per_cpu_stats_start->[$i]{idle},
			    $per_cpu_stats_end->[$i]{idle},
			    $per_cpu_stats_start->[$i]{total},
			    $per_cpu_stats_end->[$i]{total});
       my $cpu_busy_percent_without_bigints =
	   cpu_busy_percent_without_bigints($per_cpu_stats_start->[$i]{idle},
					    $per_cpu_stats_end->[$i]{idle},
					    $per_cpu_stats_start->[$i]{total},
					    $per_cpu_stats_end->[$i]{total});
       if ($cpu_busy_percent ne $cpu_busy_percent_without_bigints) {
	   die sprintf "For idle times %s %s and total times %s %s cpu_busy_percent() returned %s but cpu_busy_percent_without_bigints() returned %s\n",
	       $per_cpu_stats_start->[$i]{idle},
	       $per_cpu_stats_end->[$i]{idle},
	       $per_cpu_stats_start->[$i]{total},
	       $per_cpu_stats_end->[$i]{total},
	       $cpu_busy_percent,
	       $cpu_busy_percent_without_bigints;
       }
       $usage_per_cpu .= sprintf " %d%%", $cpu_busy_percent;
   }
   # Remove leading space.
   $usage_per_cpu = substr($usage_per_cpu, 1);
}
if ($unrecognized_cmd_stderr_output ne '') {
    printf STDERR "
The following lines were printed to stderr by the program while
being measured, and were not recognized as part of the output of the
program that is used for measurement:
        %s

%s
",
        $timemem_cmd, $unrecognized_cmd_stderr_output;
}
if ($verbose) {
    printf STDERR "\$elapsed_sec='%s'\n", $elapsed_sec;
    printf STDERR "\$user_sec='%s'\n", $user_sec;
    printf STDERR "\$sys_sec='%s'\n", $sys_sec;
    printf STDERR "\$max_rss_kbytes='%s'\n", $max_rss_kbytes;
}
if (!(defined($elapsed_sec) && defined($user_sec) &&
      defined($sys_sec) && defined($max_rss_kbytes) &&
      defined($num_cpus) && defined($usage_per_cpu) &&
      defined($cmd_exit_status)))
{
    printf STDERR "
One or more of the following values were not found in the output:
    elapsed, user, or kernel/system times
    maximum resident/working set size
    number of CPU cores, or their utilization
    command exit status
This is likely due to a change in the output format of the command
$timemem_cmd, and requires a corresponding change to $progname

The command line used was:
$cmd_to_run
";
    if ($os eq 'Cygwin') {
	printf STDERR "
Contents of batch file %s:
----------------------------------------
", $cmd_to_run;
	open(F,"$cmd_to_run") or die sprintf "Could not open file '%s' for reading.\n", $cmd_to_run;
	while (<F>) {
	    print STDERR $_;
	}
	close(F);
	printf STDERR
"----------------------------------------\n";
    }
    exit 1;
}

######################################################################
# If a check output command was given, run it to see if the output
# file's contents are good.
######################################################################

my $check_output_cmd_exit_status;
my $check_output_cmd_fail_info = '';
if (defined($output_file) && defined($check_output_cmd)) {
    $check_output_cmd =~ s/%o/$output_file/g;
    # TBD: Don't let anything sent to stdout of $check_output_cmd get
    # to our stdout, because it could mess up our XML file output.
    system($check_output_cmd);
    $check_output_cmd_exit_status = $?;
    if ($check_output_cmd_exit_status == -1) {
	printf STDERR "failed to execute cmd '%s': %s\n", $check_output_cmd, $!;
	exit 1;
    } elsif (($check_output_cmd_exit_status & 127) != 0) {
	$check_output_cmd_fail_info =
	    sprintf "check output cmd '%s' died with signal %d, %s coredump",
	        $check_output_cmd,
	        ($check_output_cmd_exit_status & 127),
	        ($check_output_cmd_exit_status & 128) ? 'with' : 'without';
    } else {
	my $child_exit_status = $check_output_cmd_exit_status >> 8;
	if ($child_exit_status != 0) {
	    $check_output_cmd_fail_info =
		sprintf "check output cmd '%s' exited with error status %d",
	            $check_output_cmd, $child_exit_status;
	}
    }
}
my $output_copy_filename;
my $save_output_copy = 0;
if ($save_temp_files) {
    $save_output_copy = 1;
} elsif ($never_save_temp_files) {
    $save_output_copy = 0;
} elsif ($check_output_cmd_fail_info ne '') {
    $save_output_copy = 1;
}
if ($save_output_copy) {
    my ($copy_succeeded, $copy_info);
    ($save_dir_name, $copy_succeeded, $copy_info, $output_copy_filename) =
	save_copy_of_file($save_dir_name, $output_file,
			  'output', 'cmd-output');
    $check_output_cmd_fail_info .= ("\n" . $copy_info);
    printf STDERR "%s\n", $check_output_cmd_fail_info;
}

# Note: If $check_output_cmd_exit_status is 0, then everything is fine.

# If it is not 0, then either it exited with a non-0 exit status, or
# it was stopped without exiting normally, e.g. via a signal.  No
# matter what non-0 value it is, we should conclude that we have not
# verified that the output is good.


######################################################################
# If --jvm-gc-stats option was given, read the GC log file and
# calculate summary GC performance stats.
######################################################################

my $gc_stats;
my $gc_log_copy_filename;
if (defined($gc_stats_type)) {
    $gc_stats = parse_jvm_gc_log($gc_stats_type, $gc_log_filename);
    my $save_gc_log_copy = 0;
    if ($save_temp_files) {
	$save_gc_log_copy = 1;
    } elsif ($never_save_temp_files) {
	$save_gc_log_copy = 0;
    } elsif ($gc_stats->findvalue('num_gc_log_parse_errors') != 0) {
	$save_gc_log_copy = 1;
    }
    if ($save_gc_log_copy) {
	my ($copy_succeeded, $copy_info);
	($save_dir_name, $copy_succeeded, $copy_info, $gc_log_copy_filename) =
	    save_copy_of_file($save_dir_name, $gc_log_filename,
			      'GC log', 'gc-log');
	printf STDERR "%s", $copy_info;
    }
}


######################################################################
# Print the performance stats in the desired format.
######################################################################

# TBD: (First part DONE) Make changes so that if a run has bad output,
# the bad output file is copied to a unique temporary file name that
# is reported on stderr and in the XML/stdout, so that the user
# can track down what the bad output was if they wish.  This temporary
# file should be created in the current working directory, or in a new
# temporary directory created that is *not* automatically erased when
# measureproc is done.  (Not done yet) Make an option to disable this
# copying action.

# TBD: (First part DONE) Similarly, if a GC log file cannot be parsed,
# copy it to a temporary file that will not be erased when measureproc
# is done, and report the name of the copy on stderr and in the
# XML/stdout output.  (Not done yet) Make an option that disables
# this copying action.

# TBD: percent of cpu this job got while it ran

# TBD: Is there a way to find out how much total CPU time *all other
# processes* got while this process was running?  It would be nice to
# have some kind of automated verification that the overall system
# load due to other processes was very low while running benchmark
# programs.  For an OS running in a virtual machine like VMware
# Fusion, I don't think the "guest OS" can determine how busy the CPU
# is in the "host OS", but it should at least be able to find out
# whether other processes in the "guest OS" are using much CPU time.

# TBD:
#    description string for result summary:
#        normal completion, output correct
#        normal completion, output incorrect
#	completed with exception <name>
#        unknown type of completion, output incorrect
#        killed after taking too long

# TBD: Details about the virtual machine being used, e.g. VMware
# Fusion or Parallels Desktop on a Mac, or other similar things.  This
# can make a significant difference for performance, and should be
# recorded.  This will probably require an explicit command line
# argument from the user to specify it, unless there is some kind of
# relatively simple method I can use to get the info automatically.

# TBD: Description of hardware, e.g. # of CPU cores, type, and clock
# speed of each.

# For Ubuntu Linux, some info is available in /proc/cpuinfo

# Mac OS X command to get CPU details:
# /usr/sbin/system_profiler -detailLevel full SPHardwareDataType

# Command to get OS details in a format more like in "About This Mac"
# menu item: sw_vers

# Other similar commands mentioned at:
# http://serverfault.com/questions/14981/getting-cpu-information-from-command-line-in-mac-os-x-server

my $gc_xml_keys_format_strings = [
    { key => 'number_of_gcs',
      fmt_string => "    Number of GCs             : %s\n"
    },
    { key => 'total_memory_gced_kb',
      fmt_string => "    Total memory GCed (KB)    : %s\n"
    },
    { key => 'total_gc_time_sec',
      fmt_string => "    Total GC time (sec)       : %s\n"
    },
    { key => 'maximum_total_available_memory_kb',
      fmt_string => "    Maximum total available memory (KB): %s\n"
    },
    { key => 'maximum_total_allocated_memory_kb',
      fmt_string => "    Maximum total allocated memory (KB): %s\n"
    },
    { key => 'maximum_total_live_memory_kb',
      fmt_string => "    Maximum total live memory (KB)     : %s\n"
    },
    { key => 'num_gc_log_parse_warnings',
      fmt_string => "    GC log parse warnings     : %s\n"
    },
    { key => 'num_gc_log_parse_errors',
      fmt_string => "    GC log parse errors       : %s\n"
    },
    { key => 'first_gc_log_parse_error',
      fmt_string => "    First GC log parse error  : %s\n"
    }
    ];

if ($output_format_xml) {
    
    # Create a list of tag/value pairs that represent all of the
    # measurements we have made and other info about running the
    # program.
    my $tag_text_pairs = [];
    if ($benchmark_name ne '') {
	push @{$tag_text_pairs}, 'benchmark_name', $benchmark_name;
    }
    if ($language_implementation_desc_str ne '') {
	push @{$tag_text_pairs},
	    'language_implementation', $language_implementation_desc_str;
    }
    if ($source_file_name ne '') {
	push @{$tag_text_pairs}, 'source_file_name', $source_file_name;
    }
    push @{$tag_text_pairs}, 'command_measured', $cmd_to_time;
    push @{$tag_text_pairs}, 'input_file',
        defined($input_file) ? $input_file : '';
    push @{$tag_text_pairs}, 'output_file',
        defined($output_file) ? $output_file : '';
    push @{$tag_text_pairs}, 'current_working_directory', $cwd;
    push @{$tag_text_pairs}, 'elapsed_time_sec', $elapsed_sec;
    push @{$tag_text_pairs}, 'user_cpu_time_sec', $user_sec;
    push @{$tag_text_pairs}, 'system_cpu_time_sec', $sys_sec;
    push @{$tag_text_pairs}, 'maximum_resident_set_size_kibibytes',
        $max_rss_kbytes;
    push @{$tag_text_pairs}, 'start_time', $start_time;
    push @{$tag_text_pairs}, 'end_time', $end_time;
    push @{$tag_text_pairs}, 'number_of_cpu_cores', $num_cpus;
    push @{$tag_text_pairs}, 'cpu_usage_per_core', $usage_per_cpu;
    push @{$tag_text_pairs}, 'exit_status', $cmd_exit_status;
    if (defined($output_file) && defined($check_output_cmd)) {
	push @{$tag_text_pairs}, 'command_to_check_output', $check_output_cmd;
	push @{$tag_text_pairs}, 'exit_status_of_check_cmd',
	    $check_output_cmd_exit_status;
	if ($check_output_cmd_fail_info ne '') {
	    push @{$tag_text_pairs}, 'check_output_cmd_failure_details',
	        $check_output_cmd_fail_info;
	}
    }
    if (defined($output_copy_filename)) {
	push @{$tag_text_pairs}, 'output_copy_file_name',
	    $output_copy_filename;
    }
    if (defined($gc_stats_type) && defined($gc_stats)) {
	# Copy all details from $gc_stats to $tag_text_pairs
	foreach my $h (@{$gc_xml_keys_format_strings}) {
	    my $key = $h->{key};
	    if (($key ne 'first_gc_log_parse_error') ||
		defined($gc_stats->findvalue($key)))
	    {
		push @{$tag_text_pairs}, $key, $gc_stats->findvalue($key);
	    }
	}
	if (defined($gc_log_copy_filename)) {
	    push @{$tag_text_pairs}, 'gc_log_file_name', $gc_log_copy_filename;
	}
    }
    push @{$tag_text_pairs}, 'operating_system', $os_full;
    if (defined($jvm_info_hash)) {
	push @{$tag_text_pairs},
	    'jvm_info_full_cmd', $jvm_info_hash->{'jvm_info_full_cmd'};
	foreach my $property (@{$jvm_property_names}) {
	    if (defined($jvm_info_hash->{$property})) {
		my $tag = 'jvm_' . $property;
		$tag =~ s/\./_/g;
		push @{$tag_text_pairs}, $tag, $jvm_info_hash->{$property};
	    }
	}
    }

    # Like the corresponding code in tmcurve, except:

    # tmcurve   here
    # -------   --------
    # $tree     $xmldoc
    # $root     $mlist
    # $new_elem $measurement

    my $xmldoc;
    my $mlist;
    if (defined($log_file) && -r $log_file && (-s $log_file != 0)) {
	# Append the new results to the existing results file.
	my $parser = XML::LibXML->new();
	$xmldoc = $parser->parse_file($log_file);
	# TBD: What to do if there is an error parsing existing file
	# contents as XML?  Or it is an XML file with a different
	# structure than expected?
	$mlist = $xmldoc->getDocumentElement;
    } else {
	# Create a new XML file with the current results.
	$xmldoc = XML::LibXML::Document->new();
	# ... with root element having tag MeasurementList
	$mlist = $xmldoc->createElement('MeasurementList');
	$xmldoc->setDocumentElement($mlist);
    }

    # ... and that root element has a first child with tag Measurement
    my $measurement = $xmldoc->createElement('Measurement');
    $mlist->appendChild($measurement);

    # Add the tag/text pairs as children of the $measurement element.
    libxml_add_children_to_elem($xmldoc, $measurement, $tag_text_pairs);

    # and finally print out the XML file.
    if (defined($log_file)) {
	my $fh;
	open $fh, ">", $log_file;
	# TBD: Check for failure to open the file for writing.
	print $fh $xmldoc->toString(1);
	close $fh;
    } else {
	# Write XML to stdout
	print $xmldoc->toString(1);
    }

} else {

    my $log;
    if (defined($log_file)) {
	open($log, ">>$log_file")
	    or die sprintf "Could not open log file '%s' for appending: %s",
	               $log_file, $!;
    } else {
	$log = *STDOUT;
    }

    if ($benchmark_name ne '') {
	printf $log "    Benchmark name            : %s\n", $benchmark_name;
    }
    if ($language_implementation_desc_str ne '') {
	printf $log "    Language implementation   : %s\n", $language_implementation_desc_str;
    }
    if ($source_file_name ne '') {
	printf $log "    Source file name          : %s\n", $source_file_name;
    }
    printf $log "    Command measured          : %s\n", $cmd_to_time;
    if (defined($input_file)) {
	printf $log "    Input file                : %s\n", $input_file;
    }
    if (defined($output_file)) {
	printf $log "    Output file               : %s\n", $output_file;
    }
    printf $log "    Current working directory : %s\n", $cwd;
    printf $log "    Elapsed time (sec)        : %s\n", $elapsed_sec;
    printf $log "    User CPU time (sec)       : %s\n", $user_sec;
    printf $log "    System CPU time (sec)     : %s\n", $sys_sec;
    printf $log "    Max resident set size (KB): %s\n", $max_rss_kbytes;
    printf $log "    Start time                : %s\n", $start_time;
    printf $log "    End time                  : %s\n", $end_time;
    printf $log "    Per core CPU usage (%d cores): %s\n", $num_cpus, $usage_per_cpu;
    printf $log "    Exit status               : %s\n", $cmd_exit_status;
    if (defined($output_file) && defined($check_output_cmd)) {
	printf $log "    Command to check output   : %s\n", $check_output_cmd;
	printf $log "    Exit status of check cmd  : %s\n", $check_output_cmd_exit_status;
	if ($check_output_cmd_fail_info ne '') {
	    printf $log "Failure details of command used to check output: %s\n",
	        $check_output_cmd_fail_info;
	}
    }
    if (defined($output_copy_filename)) {
	printf $log "    Output copy file name     : %s\n",
	    $output_copy_filename;
    }
    if (defined($gc_stats_type) && defined($gc_stats)) {
	my $print_gc_details = 1;
	if ($gc_stats->findvalue('number_of_gcs') == 0) {
	    # If the number of GCs invocations is 0, then the rest of
	    # the GC stats are 0, too, so don't bother showing them.
	    $print_gc_details = 0;
	}
	foreach my $h (@{$gc_xml_keys_format_strings}) {
	    my $key = $h->{key};
	    my $fmt_string = $h->{fmt_string};
	    my $val = $gc_stats->findvalue($key);
	    my $show_this = 0;
	    if ($key eq 'number_of_gcs') {
		$show_this = 1;
	    } elsif ($key eq 'first_gc_log_parse_error') {
		if ($val ne '') {
		    $show_this = 1;
		}
	    } elsif (($key eq 'num_gc_log_parse_warnings') ||
		     ($key eq 'num_gc_log_parse_errors'))
	    {
		if ($val != 0) {
		    $show_this = 1;
		}
	    } else {
		$show_this = $print_gc_details;
	    }
	    if ($show_this) {
		printf $log $fmt_string, $val;
	    }
	}
	if (defined($gc_log_copy_filename)) {
	    printf $log "    GC log file name          : %s\n",
	        $gc_log_copy_filename;
	}
    }
    printf $log "    OS description            : %s\n", $os_full;
    if (defined($jvm_info_hash)) {
	printf $log "    %-26s: %s\n",
	    'JVM info full command', $jvm_info_hash->{'jvm_info_full_cmd'};
	foreach my $property (@{$jvm_property_names}) {
	    if (defined($jvm_info_hash->{$property})) {
		my $desc = 'JVM ' . $property;
		printf $log "    %-26s: %s\n",
		    $desc, $jvm_info_hash->{$property};
	    }
	}
    }
}

exit 0;


# Referring to the "Specification" section of this Wikipedia page:

# http://en.wikipedia.org/wiki/Comma-separated_values

# especially the "Basic rules" part of that section, it appears to me
# that I should be able to take _any_ string I want to put in a CSV
# field, whether it has quotes, commas, semicolons, etc. or not, put
# enclose it in double quotes, and replace all double quotes within
# the string with two consecutive double quotes, and it should be
# valid.  If I'm misunderstanding that, then I should be able to fix
# it by modifying this function.

sub csv_str {
    my $str = shift;
    my $csv_str;

    $csv_str = $str;
    # Try to only put double-quotes around strings that need them.
    # Note that while strings containing spaces might not need double
    # quotes, I'll go ahead and be extra-safe by doing so.
    if ($csv_str =~ /,|"|\s|\n/) {
	$csv_str =~ s/"/""/g;
	return '"' . $csv_str . '"';
    }
    return $csv_str;
}


sub linux_get_cpu_usage {
    my $per_cpu_stats = [];
    my $total_cpu_stats = {};

    my $filename = '/proc/stat';
    open(F,"$filename") or die sprintf "Could not open file '%s' for reading.\n", $filename;
    my $line = <F>;
    if ($line =~ /^\s*cpu\s+(\d+) (\d+) (\d+) (\d+)/) {
	my ($user, $nice, $sys, $idle) = ($1, $2, $3, $4);
        $total_cpu_stats->{user} = $user;
        $total_cpu_stats->{nice} = $nice;
        $total_cpu_stats->{sys} = $sys;
        $total_cpu_stats->{idle} = $idle;
        $total_cpu_stats->{total} = add_big_ints([$user, $nice, $sys, $idle]);
        $total_cpu_stats->{frequency} = 100;
    } else {
        die sprintf "linux_get_cpu_usage: Expected cpu at beginning of line, but found the following line instead:\n%s", $line;
    }

    my $i = 0;
    while ($line = <F>) {
        #printf STDERR "\$i=%s \$line='%s'\n", $i, $line;
        if ($line =~ /^\s*cpu(\d+) (\d+) (\d+) (\d+) (\d+)/) {
            my ($cpu, $user, $nice, $sys, $idle) = ($1, $2, $3, $4, $5);
            my $one_cpu_stats = {};
            if ($i != $cpu) {
               die sprintf "linux_get_cpu_usage: Expected cpu%d at beginning of line, but found cpu%d instead.\n", $i, $cpu;
            }
            $one_cpu_stats->{user} = $user;
            $one_cpu_stats->{nice} = $nice;
            $one_cpu_stats->{sys} = $sys;
            $one_cpu_stats->{idle} = $idle;
	    $one_cpu_stats->{total} = add_big_ints([$user, $nice, $sys, $idle]);
            $one_cpu_stats->{frequency} = 100;
            $per_cpu_stats->[$i] = $one_cpu_stats;
            $i++;
        } else {
            last;
        }
    }
    close(F);
    return ($per_cpu_stats, $total_cpu_stats);
}


# Take a list of strings containing integers as an argument, where the
# strings can contain arbitrarily large integers.  Add them and return
# the sum as a string.

sub add_big_ints {
    my $nums = shift;

    my $str = shift @{$nums};
    my $bigint_sum = Math::BigInt->new($str);
    foreach $str (@{$nums}) {
	my $x = Math::BigInt->new($str);
	$bigint_sum->badd($x);
    }
    return sprintf "%s", $bigint_sum;
}


sub cpu_busy_percent {
    my $idle1 = shift;
    my $idle2 = shift;
    my $total1 = shift;
    my $total2 = shift;

    my $total1_bi = Math::BigInt->new($total1);
    my $total_bi = Math::BigInt->new($total2);
    $total_bi->bsub($total1_bi);
    if ($total_bi->is_zero()) {
	return "0";
    } else {
	my $idle1_bi = Math::BigInt->new($idle1);
	my $idle_bi = Math::BigInt->new($idle2);
	$idle_bi->bsub($idle1_bi);

	# Now calculate 100 - ((100 * $idle_bi) / $total_bi), rounded
	# to nearest whole number.  To do that, we will calculate
	# ((1000 * ($total_bi - $idle_bi)) / $total_bi), then do the
	# rounding manually ourselves.  I'm sure that Perl's
	# Math::BigInt package provides a more succinct way of doing
	# this, but this will give the correct answer.
        my $busy_bi = $idle_bi->copy();
        $busy_bi->bsub($total_bi);
        $busy_bi->bneg();
	$busy_bi->bmul(1000);
	$busy_bi->bdiv($total_bi);

	my $last_digit_bi = $busy_bi->copy();
	$last_digit_bi->bmod(10);
	my $cpu_busy_percent_bi = $busy_bi->copy();
	$cpu_busy_percent_bi->bdiv(10);
	if ($last_digit_bi->bcmp(5) >= 0) {   # i.e. ($last_digit_bi >= 5)
	    $cpu_busy_percent_bi->binc();
	}
	return sprintf "%s", $cpu_busy_percent_bi;
    }
}


sub cpu_busy_percent_without_bigints {
    my $idle1 = shift;
    my $idle2 = shift;
    my $total1 = shift;
    my $total2 = shift;

    my $total = ($total2 - $total1);
    my $cpu_busy_percent = 0;
    if ($total != 0) {
	my $idle = ($idle2 - $idle1);
	$cpu_busy_percent = sprintf "%d", (100.0 * (1.0 - (1.0 * $idle) / $total)) + 0.5;
    }
    return sprintf "%d", $cpu_busy_percent;
}


sub time_cmd_location {
    my $os = shift;
    my $install_dir = shift;

    my $timemem_cmd;

    if ($os eq 'Cygwin') {
	$timemem_cmd = $install_dir . "/timemem";
	$timemem_cmd = `cygpath -w "$timemem_cmd"`;
	chomp $timemem_cmd;
    } elsif ($os eq 'Darwin') {
	$timemem_cmd = $install_dir . "/timemem-darwin";
    } elsif ($os eq 'GNU/Linux') {
	$timemem_cmd = "/usr/bin/time -v";
    } else {
	printf STDERR "Unknown OS string '%s'.  Only 'Cygwin', 'Darwin', and 'GNU/Linux' are supported.  Aborting.", $os;
	exit 1;
    }
    return $timemem_cmd;
}


sub sumgclog_location {
    my $os = shift;
    my $install_dir = shift;

    my $sumgclog_cmd;

    $sumgclog_cmd = $install_dir . "/sumgclog";
    if (-x $sumgclog_cmd) {
	return $sumgclog_cmd;
    } else {
	# Don't print a warning until and unless we know the user
	# actually wants to do GC log analysis.
	return undef;
    }
}


sub libxml_add_children_to_elem {
    my $xmldoc = shift;
    my $elem = shift;
    my $tag_text_pairs = shift;

    my $n = $#{$tag_text_pairs};
    my $i;
    for ($i = 0; $i < $n; $i += 2) {
	my $tag_str = $tag_text_pairs->[$i];
	my $text_str = $tag_text_pairs->[$i+1];
	my $child = $xmldoc->createElement($tag_str);
	my $text = XML::LibXML::Text->new($text_str);
	$child->appendChild($text);
	$elem->appendChild($child);
    }
}


sub parse_jvm_gc_log {
    my $gc_stats_type = shift;
    my $gc_log_filename = shift;

    if (!defined($sumgclog_cmd)) {
	printf STDERR "Command '%s' either does not exist or is not an executable program.  No GC log analysis will be performed.\n";
	return undef;
    }
    my $args = [];
    push @{$args}, '--xml';
    my ($fh, $temp_log_filename) = tempfile( DIR => $tempdir );
    # Do I need to close this before opening the file for reading?  Or
    # could I simply use it to read the file from the beginning?
    # Seems safer to close this and open the file by name later.
    close $fh;
    push @{$args}, '--log-file', $temp_log_filename;
    if (defined($gc_stats_type)) {
	push @{$args}, '--jvm-gc-stats', $gc_stats_type;
    }
    push @{$args}, $gc_log_filename;

    # Run sumgclog
    my $exit_status = system $sumgclog_cmd, @{$args};
    # TBD: At least for now, ignore exit status of sumgclog.

    if (-r $temp_log_filename) {
	my $parser = XML::LibXML->new();
	my $tree = $parser->parse_file($temp_log_filename);
	my $root = $tree->getDocumentElement;
	my $all_measurements = $root->findnodes('Measurement');
	# There should only be one element in that list.
	my $measurement_xml_info = $all_measurements->[0];
	return $measurement_xml_info;
    } else {
	printf "Temporary log file '%s' created for sumgclog was not created.  Assume failure." if ($verbose >= 1);
	return undef;
    }
}


sub save_copy_of_file {
    my $save_dir_name = shift;
    my $filename_to_save = shift;
    my $file_desc = shift;
    my $save_file_base_name = shift;

    if (!defined($save_dir_name)) {
	$save_dir_name = tempdir( $progname . '-XXXXXX', DIR => '.',
				  CLEANUP => 0 );
	# TBD: Check whether tempdir() succeeded, and print an error
	# message if it didn't.
    }
    my ($fh, $copy_filename) = tempfile( $save_file_base_name . '-XXXXXX',
					 DIR => $save_dir_name );
    close($fh);
    my $copy_succeeded;
    my $copy_info;
    if (copy($filename_to_save, $copy_filename)) {
	$copy_succeeded = 1;
	$copy_info =
	    sprintf "Copy of %s file '%s' (length %d bytes) saved as '%s'",
	        $file_desc, $filename_to_save, -s $filename_to_save,
	        $copy_filename;
    } else {
	$copy_succeeded = 0;
	$copy_info =
	    sprintf "Attempted to copy %s file '%s' (length %d bytes) as '%s', but failed: %s",
	        $file_desc, $filename_to_save, -s $filename_to_save,
	        $copy_filename, $!;
	$copy_filename = undef;
    }
    return ($save_dir_name, $copy_succeeded, $copy_info, $copy_filename);
}
