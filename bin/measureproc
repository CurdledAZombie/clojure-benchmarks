: # use perl -*-Perl-*-
eval 'exec perl -S "$0" ${1+"$@"}'
    if 0;
# -*cperl-*-

use strict;
use Getopt::Long;
use File::Basename;
# File::Temp is a library for creating temporary files.
use File::Temp qw/ tempfile tempdir /;
use File::Copy;
# FindBin is a library to find the directory in which the script is
# installed.  This can be useful for making it easy to install other
# auxiliary files needed by the script all in one place, and no matter
# where someone installs 'the whole package' of files, the script can
# find them, without needing hand-editing.
use FindBin;
use IPC::Open3;
use Symbol qw(gensym);
use IO::File;
use Math::BigInt;
use XML::LibXML;
use Cwd;


my $verbose = 0;
my $full_progname = $0;
my $progname = fileparse($full_progname);
my $save_dir_name;

my $os = `uname -o 2>/dev/null`;
if ($? != 0) {
    # Then likely we are running on a Mac OS X system with the default
    # uname installation, which accepts -s but not -o option.
    $os = `uname -s 2>/dev/null`;
}
chomp $os;
my $os_full = `uname -a`;
chomp $os_full;
my $cwd = cwd();

my $install_dir = $FindBin::Bin;
my $timemem_cmd = time_cmd_location($os, $install_dir);


sub usage {
    print STDERR
"usage: $progname [ --help ] [ --verbose ]
               [ --xml ]
               [ --csv ] [ --name-row ]
               [ --log-file <log_file> ]
               [ --input-file <input_file> ]
               [ --output-file <output_file> ]
               [ --check-output-cmd <check_output_cmd> ]
               [ --os <os_name> ]
               [ --time-cmd <time_cmd> ]
               [ --language <language_implementation_description_string> ]
               [ --benchmark <benchmark_problem_name> ]
               [ --source-file-name <source_file_name> ]
               [ --jvm-info { client | server } ]
               [ --jvm-cmd <jvm_command> ]
               [ --jvm-gc-stats <jvm_type> ]
               [ --jruby-gc-stats <jvm_type> ]
               <measured_cmd> [ arg1 ... ]

    --help        Show this help.

    --verbose     Enable debug messages.

    --xml         Print measurement output in XML format.

    --csv         Print measurement output in CSV format, not really
                  intended for human consumption.

    --name-row    If --csv is given, then also print a 'header line'
                  giving the name of each field in the output CSV
                  file, in addition to the measurements line.

    --log-file <log_file>
                  Append measurement output to file <log_file>,
                  creating <log_file> if it does not exist already.

    --input-file <input_file>
                  Input file for <measured_cmd> (optional).  If
                  provided, <measured_cmd> will be invoked with its
                  standard input redirected from <input_file>.

    --output-file <output_file>
                  Similar to --input-file, except it is a file name
                  where <measure_cmd>'s standard output will be
                  redirected into, if provided.

    --check-output-cmd <check_output_cmd>
                  A command string used to check whether the output
                  file's contents are good.  The command's exit status
                  should be 0 (i.e. no error) if the output is good,
                  or any non-zero value if the output is not good.

                  This command string may have occurences of %o in it.
                  If so, $progname will replace all such occurrences
                  with the output file name.  This option should only
                  be given if --output-file is also given.

    --os <os_name>
                  Can be used to specify one of the supported OSs:
                      Cygwin
                      Darwin
                      GNU/Linux
                  This command line option need only be used to
                  override the default of '$os', which is detected via
                  the output of the 'uname -o' command.

    --time-cmd <time_cmd>
                  Specify the command to use to measure the running
                  time and memory usage of the process.  This is only
                  needed if you wish to override the default command,
                  which for platform '$os' is: $timemem_cmd

    --jvm-info { client | server }
    --jvm-cmd <jvm_command>
                  When this option is used, $progname will run a small
                  compiled Java program JVMInfo.class that should be
                  installed in the same directory as $progname, before
                  running <measured_cmd>.  This program will print
                  some information such as the host OS, JVM version,
                  and number of available processors, among other
                  things, and $progname will collect this and include
                  it in the output.

                  Likely most of this information will be the same
                  regardless of whether a -client or -server command
                  line option is used, but in case they are different,
                  you must specify which to use by the string that
                  appears after --jvm-info on the command line.

                  If the --jvm-cmd option is specified, $progname will
                  use that as the command to use when invoking the JVM
                  to execute JVMInfo.class.  If no --jvm-cmd option is
                  specified, $progname wil use the first 'word' of
                  <measured_cmd> as the name of the command to invoke
                  the JVM.

                  (TBD: This should be tested with path names that
                  have spaces in them to see whether it works in that
                  case or not).

    --jvm-gc-stats <jvm_type>
                  When this option is used, $progname will assume that
                  <measured_cmd> is an invocation of a Java virtual
                  machine that takes an additional command line option
                  in order to report information about garbage
                  collection (GC) invocation.  What the option is
                  depends upon what kind of JVM is in use.  The
                  following are supported by $progname:

                    --jvm-gc-stats hotspot
                        -Xloggc:<gc_log_file>
                    --jvm-gc-stats jrockit  (not yet implemented)
                        -Xverbose:memory -Xverboselog:<gc_log_file>

                  $progname will modify the command line given to add
                  options like the ones above, with the name of an
                  auto-generated temporary file name, and then parse
                  the contents of this file when <measured_cmd> exits.
                  Some summary statistics about the contents will be
                  reported.

    --jruby-gc-stats <jvm_type>
                  This is the same as --jvm-gc-stats, except that the
                  command line option added to the command line will
                  have a '-J' prepended to it, as required by the
                  jruby command in order to pass the options through
                  to the JVM invocation.

    The options below do not affect how the command is run or its
    performance measured.  They are simply printed to the output for
    inclusion in whatever results the user wishes to collect.  They
    could be useful later for keeping track of which results are
    which.

    --language <language_implementation_description_string>
    --benchmark <benchmark_problem_name>
    --source-file-name <source_file_name>

Note that command line options can be abbreviated to the shortest
prefix that uniquely identifies them.

Example of use on Linux or Mac OS X:

  % $progname --input input/medium-input.txt --output output/medium-clj-1.2-output.txt java -version
  [ ... output removed ... ]

  % $progname --input input/medium-input.txt --output output/medium-clj-1.2-output.txt java -server -Xmx1536m -classpath ~/lein/swank-clj-1.2.0/lib/clojure-1.2.0.jar:./obj/clj-1.2 knucleotide
  [ ... output removed ... ]

  % $progname --input input/quick-input.txt --output output/quick-clj-1.2-output.txt --check 'diff --strip-trailing-cr --brief output/quick-expected-output.txt %o' java -server -Xmx1536m -classpath ~/lein/swank-clj-1.2.0/lib/clojure-1.2.0.jar:./obj/clj-1.2 knucleotide
      Command measured          : java -server -Xmx1536m -classpath /Users/andy/lein/swank-clj-1.2.0/lib/clojure-1.2.0.jar:./obj/clj-1.2 knucleotide
      Elapsed time (sec)        : 2.857
      User CPU time (sec)       : 3.107
      System CPU time (sec)     : 0.302
      Max resident set size (kb): 80992
      Start time                : Wed Nov 10 18:55:06 2010
      End time                  : Wed Nov 10 18:55:08 2010
      Per core CPU usage (2 cores): 92% 90%
      Exit status               : 0
      Command to check output   : diff --strip-trailing-cr --brief output/quick-expected-output.txt output/quick-clj-1.2-output.txt
      Exit status of check cmd  : 0
      OS description            : Darwin andys-mbp.local 9.8.0 Darwin Kernel Version 9.8.0: Wed Jul 15 16:55:01 PDT 2009; root:xnu-1228.15.4~1/RELEASE_I386 i386 i386 MacBookPro4,1 Darwin

Examples of use on Windows XP + Cygwin:

  % $progname --input input\\\\medium-input.txt --output output\\\\medium-clj-1.2-output.txt \\\\Program\\ Files\\\\Java\\\\jrmc-4.0.1-1.6.0\\\\bin\\\\java -version
  [ ... output removed ... ]

  % $progname --verbose --input input\\\\quick-input.txt --output output\\\\quick-clj-1.2-output.txt \\\\Program\\ Files\\\\Java\\\\jrmc-4.0.1-1.6.0\\\\bin\\\\java -server -Xmx1536m -classpath \"\\\\cygwin\\\\home\\\\Admin\\\\lein\\\\swank-clj-1.2.0\\\\lib\\\\clojure-1.2.0.jar;.\\\\obj\\\\clj-1.2\" knucleotide
  [ ... output removed ... ]
";
}

######################################################################
# Get command line options
######################################################################

my $help;
my $csv;
my $output_format_xml;
my $output_format_csv;
my $print_csv_name_row;
my $log_file;
my $input_file;
my $output_file;
my $check_output_cmd;
my $os_from_cmd_line;
my $time_cmd_from_cmd_line;
my $jvm_info;
my $jvm_cmd;
my $jvm_gc_stats_from_cmd_line;
my $jruby_gc_stats_from_cmd_line;
my $language_implementation_desc_str = '';
my $benchmark_name = '';
my $source_file_name = '';
Getopt::Long::Configure('require_order');
if (!GetOptions('help' => \$help,
		'verbose' => \$verbose,
		'xml' => \$output_format_xml,
		'csv' => \$output_format_csv,
		'name-row' => \$print_csv_name_row,
		'log-file=s' => \$log_file,
		'input-file=s' => \$input_file,
		'output-file=s' => \$output_file,
		'check-output-cmd=s' => \$check_output_cmd,
		'os=s' => \$os_from_cmd_line,
		'time-cmd=s' => \$time_cmd_from_cmd_line,
                'jvm-info=s' => \$jvm_info,
                'jvm-cmd=s' => \$jvm_cmd,
                'jvm-gc-stats=s' => \$jvm_gc_stats_from_cmd_line,
                'jruby-gc-stats=s' => \$jruby_gc_stats_from_cmd_line,
		'language=s' => \$language_implementation_desc_str,
		'benchmark=s' => \$benchmark_name,
		'source-file-name=s' => \$source_file_name
               ))
{
    usage();
    exit(1);
}

$os = $os_from_cmd_line if (defined($os_from_cmd_line));
if ($verbose) {
    printf STDERR "\$os='%s'\n", $os;
    printf STDERR "install dir='%s'\n", $FindBin::Bin;
}
if ($help) {
    usage();
    exit(0);
}
if ($output_format_csv and $output_format_xml) {
    printf STDERR
"Should supply at most one of the --csv and --xml options for
selecting the output format.
";
    usage();
    exit(1);
}
if ($print_csv_name_row and !$output_format_csv) {
    printf STDERR
"Option --name-row has no effect, and should not be given, unless
--csv output format is selected.
";
    usage();
    exit(1);
}
if (defined($jvm_info)) {
    if (! (($jvm_info eq 'client') || ($jvm_info eq 'server')) ) {
	printf STDERR
"The value after --jvm-info must be 'client' or 'server'.  Found '%s'.
", $jvm_info;
	exit 1;
    }
}
my $gc_stats_type;
my $gc_stats_jruby;
if (defined($jvm_gc_stats_from_cmd_line) &&
    defined($jruby_gc_stats_from_cmd_line))
{
    printf STDERR
"At most one of --jvm-gc-stats and --jruby-gc-stats should be
specified, depending on whether the measured command is a jruby
invocation or a java invocation.
";
    exit 1;
}
if (defined($jruby_gc_stats_from_cmd_line)) {
    $gc_stats_type = $jruby_gc_stats_from_cmd_line;
    $gc_stats_jruby = 1;
} elsif (defined($jvm_gc_stats_from_cmd_line)) {
    $gc_stats_type = $jvm_gc_stats_from_cmd_line;
    $gc_stats_jruby = 0;
}
if (defined($gc_stats_type)) {
    if ($gc_stats_type eq 'hotspot') {
        # OK
    } elsif ($gc_stats_type eq 'jrockit') {
        # OK
    } else {
        printf STDERR
"Unrecognized value '%s' given after option %s
The following are supported: hotspot jrockit
",
            $gc_stats_type,
            ($gc_stats_jruby ? '--jruby-gc-stats' : '--jvm-gc-stats');
        exit 1;
    }
}
$timemem_cmd = (defined($time_cmd_from_cmd_line) ? $time_cmd_from_cmd_line
		: time_cmd_location($os, $install_dir));
if ($timemem_cmd =~ /^(\S+)/) {
    my $cmd = $1;
    if (! -x $cmd) {
	die sprintf "There is no command '$cmd' to measure performance for your command\n";
    }
}
if ($#ARGV < 0) {
    printf STDERR "No command given.\n";
    usage();
    exit 1;
}

my $tempdir;
if (($os eq 'Cygwin') || defined($gc_stats_type)) {
    # We will later use a temporary directory for creating one or more
    # temporary files.
    $tempdir = tempdir( CLEANUP => 1 );
}

my $log;
if (defined($log_file)) {
    open($log, ">>$log_file")
	or die sprintf "Could not open log file '%s' for appending: %s",
	                $log_file, $!;
} else {
    $log = *STDOUT;
}

######################################################################
# Construct command to run (and measure its performance)
######################################################################

my $gc_log_filename;
my $cmd_first_word = shift @ARGV;
if ($os eq 'Cygwin') {
    # timemem.exe expects a DOS/Windows file name for the command, but
    # when writing shell scripts that we want to work on both
    # Windows+Cygwin and Linux/Mac OS X, it is sometimes inconvenient
    # to make a separate case for such things.

    # Let cygpath -w convert it to DOS/Windows if it is not.  If it
    # already is, cygpath -w seems to recognize this and leave it
    # alone.
    $cmd_first_word = `cygpath -w "$cmd_first_word"`;
    chomp $cmd_first_word;
}
my $cmd_to_time = $cmd_first_word;
if (defined($gc_stats_type)) {
    my $tempfh;
    ($tempfh, $gc_log_filename) = tempfile( DIR => $tempdir,
					    SUFFIX => '.txt' );
    my $log_fname = $gc_log_filename;
    if ($os eq 'Cygwin') {
	$log_fname = `cygpath -w $gc_log_filename`;
	chomp $log_fname;
    }
    my $prefix = ($gc_stats_jruby ? '-J' : '');
    if ($gc_stats_type eq 'hotspot') {
        $cmd_to_time .= (sprintf ' %s-Xloggc:%s', $prefix, $log_fname);
    } elsif ($gc_stats_type eq 'jrockit') {
        $cmd_to_time .= (sprintf ' %s-Xverbose:memory %s-Xverboselog:%s',
                             $prefix, $prefix, $log_fname);
    }
}
$cmd_to_time .= (' ' . join(' ', @ARGV));

if ($verbose) {
    printf STDERR "\$cmd_to_time='%s'\n", $cmd_to_time;
}

my $cmd_str = '';
my $cmd_begin = '';
my $cmd_end = '';
if ($os eq 'Cygwin') {
    $cmd_begin = '"';
    $cmd_end = '"';
}
$cmd_str .= sprintf "%s %s%s%s", $timemem_cmd, $cmd_begin, $cmd_to_time, $cmd_end;
if (defined($input_file)) {
    $cmd_str .= sprintf " < %s", $input_file;
}
if (defined($output_file)) {
    $cmd_str .= sprintf " > %s", $output_file;
}
if ($verbose) {
    printf STDERR "\$cmd_str='%s'\n", $cmd_str;
}

my $cmd_to_run;
if ($os eq 'Cygwin') {
    # On Cygwin, put the command into a BAT file for execution.
    my ($fh, $batchfile) = tempfile( DIR => $tempdir, SUFFIX => '.bat' );
    if ($verbose) {
	printf STDERR "\$tempdir='%s'\n", $tempdir;
    }
    printf $fh "%s\n", $cmd_str;
    close $fh;
    chmod 0755, $batchfile;
    $cmd_to_run = $batchfile;
} else {
    $cmd_to_run = $cmd_str;
}
if ($verbose) {
    printf STDERR "\$cmd_to_run='%s'\n", $cmd_to_run;
}


######################################################################
# If requested, run the JVM to get some information about it and the
# host machine and OS.
######################################################################

my $jvm_property_names = [
    'os.arch',
    'availableProcessors',
    'os.name',
    'os.version',
    'java.version',
    'java.specification.version',
    'java.vm.name',
    'java.vm.version',
    'java.runtime.version',
    'sun.arch.data.model' ];
my $jvm_property_xml_tags = {
    'os.arch' => 'jvm_os_arch',
    'availableProcessors' => 'jvm_availableProcessors',
    'os.name' => 'jvm_os_name',
    'os.version' => 'jvm_os_version',
    'java.version' => 'jvm_java_version',
    'java.specification.version' => 'jvm_java_specification_version',
    'java.vm.name' => 'jvm_java_vm_name',
    'java.vm.version' => 'jvm_java_vm_version',
    'java.runtime.version' => 'jvm_java_runtime_version',
    'sun.arch.data.model' => 'jvm_sun_arch_data_model'
};

my $jvm_info_hash;
if (defined($jvm_info)) {
    if (!defined($jvm_cmd)) {
	$jvm_cmd = $cmd_first_word;
    }
    my $jvm_cmd_to_use = $jvm_cmd;
    if ($os eq 'Cygwin') {
	$jvm_cmd_to_use = `cygpath -u "$jvm_cmd"`;
	chomp $jvm_cmd_to_use;
    }
    my $jvm_cmd_list = [ $jvm_cmd_to_use ];
    my $install_dir_to_use = $install_dir;
    if ($os eq 'Cygwin') {
	$install_dir_to_use = `cygpath -w "$install_dir"`;
	chomp $install_dir_to_use;
    }
    push @{$jvm_cmd_list}, ('-' . $jvm_info),
        '-classpath', $install_dir_to_use, 'JVMInfo';
    my $jvm_cmd_string = join(' ', @{$jvm_cmd_list});
    open (JVM_OUT, '-|', @{$jvm_cmd_list})
	or die sprintf "Could not execute command '%s' and read its output.\n",
	    $jvm_cmd_string;
    my $line;
    $jvm_info_hash->{'jvm_info_full_cmd'} = $jvm_cmd_string;
    while ($line = <JVM_OUT>) {
	if ($line =~ /^([^=]+)=(.*)$/) {
	    my ($property, $val) = ($1, $2);
	    if (defined($jvm_property_xml_tags->{$property})) {
		$jvm_info_hash->{$property} = $val;
	    } else {
		die sprintf
"Unrecognized property name '%s' in output line from command '%s':\n%s",
	            $property, $jvm_cmd_string, $line;
	    }
	} else {
	    die sprintf "Unrecognized output line from command '%s':\n%s",
	        $jvm_cmd_string, $line;
	}
    }
    close(JVM_OUT);
}


######################################################################
# Run the command, and read performance stats from its standard error
# output.
######################################################################

my ($elapsed_sec, $user_sec, $sys_sec, $max_rss_kbytes);
my $num_cpus;
my $usage_per_cpu = 'not calculated';
my ($per_cpu_stats_start, $total_cpu_stats_start);
my ($per_cpu_stats_end, $total_cpu_stats_end);

# I want to run the program and read its stderr output.  I'll assume
# that stdout is already being saved to a file, and ignore anything
# that goes to stdout.

# This is a slight modification of some sample code I found at:
# http://perldoc.perl.org/perlfaq8.html#How-can-I-capture-STDERR-from-an-external-command?

local *CATCHERR = IO::File->new_tmpfile;
if (($os eq 'GNU/Linux') || ($os eq 'Cygwin')) {
    ($per_cpu_stats_start, $total_cpu_stats_start) = linux_get_cpu_usage();
}
my $start_time = localtime();
my $pid = open3(gensym, \*CATCHOUT, ">&CATCHERR", $cmd_to_run);
while (<CATCHOUT>) {
}
waitpid($pid, 0);
my $child_exit_status = $? >> 8;
my $end_time = localtime();
if (($os eq 'GNU/Linux') || ($os eq 'Cygwin')) {
    ($per_cpu_stats_end, $total_cpu_stats_end) = linux_get_cpu_usage();
}
seek CATCHERR, 0, 0;

my $cmd_exit_status;
my $unrecognized_cmd_stderr_output = '';
if ($os eq 'Cygwin') {
    my $found_pid = 0;
    while (<CATCHERR>) {
	chomp;
	s/\r$//;
	if (/^Process ID/) {
	    $found_pid = 1;
        } elsif (/^\s*Dumping CPU usage by sampling running threads \.\.\. done\.\s*$/) {
            # Ignore this line if JVM profiling via sampling was
            # enabled.
	} elsif ($found_pid) {
	    if (/^\s+exit code: (.*)\s*$/) {
		$cmd_exit_status = $1;
	    } elsif (/^\s+elapsed time \(seconds\): (.*)\s*$/) {
		$elapsed_sec = $1;
	    } elsif (/^\s+user time \(seconds\): (.*)\s*$/) {
		$user_sec = $1;
	    } elsif (/^\s+kernel time \(seconds\): (.*)\s*$/) {
		$sys_sec = $1;
	    } elsif (/^\s+Peak Working Set Size \(kbytes\): (\d+)\s*$/) {
		$max_rss_kbytes = $1;
	    } elsif (/^\s+Page Fault Count: (\d+)\s*$/) {
		# Ignore this and the ones immediately below
	    } elsif (/^\s+Quota Peak Paged Pool Usage: (\d+)\s*$/) {
	    } elsif (/^\s+Quota Peak Non Paged Pool Usage: (\d+)\s*$/) {
	    } elsif (/^\s+Peak Pagefile Usage: (\d+)\s*$/) {
	    } else {
		if (! /^\s*$/) {
		    $unrecognized_cmd_stderr_output .= ($_ . "\n");
		}
	    }
	} else {
	    # This is a line of output from the program, most likely
	    # one printed to stderr if stdout has been redirected.
	    if (! /^\s*$/) {
		$unrecognized_cmd_stderr_output .= ($_ . "\n");
	    }
	}
    }
} elsif ($os eq 'Darwin') {
    $cmd_exit_status = $child_exit_status;
    my $found_real = 0;
    if ($verbose) {
	printf STDERR "Reading stderr output of command: %s\n", $cmd_to_run;
    }
    while (<CATCHERR>) {
	chomp;
	if ($verbose) {
	    printf STDERR "stderr line: %s\n", $_;
	}
	if (/^\s*real\s+(.*)\s*$/) {
	    $elapsed_sec = $1;
	    $found_real = 1;
	} elsif (/^\s*Dumping CPU usage by sampling running threads \.\.\. done\.\s*$/) {
	    # Ignore this line if JVM profiling via sampling was
	    # enabled.
	} elsif ($found_real) {
	    if (/^\s*user\s+(.*)\s*$/) {
		$user_sec = $1;
	    } elsif (/^\s*sys\s+(.*)\s*$/) {
		$sys_sec = $1;
	    } elsif (/^\s*(\d+)\s+maximum resident set size from (getrusage|polling).*\s*$/)
	    {
		# Mac OS X 10.5.* reports max RSS from getrusage in
		# units of bytes.  Convert to kbytes.  Use BigInt
		# arithmetic, in case the integer is very large.

		# Mac OS X 10.6.* always reports 0 for max RSS from
		# getrusage, so the measurement obtained from periodic
		# polling of the current resident set size should be
		# used.
		my $max_rss_kbytes_bi = Math::BigInt->new($1);
		my $measurement_type = $2;
		# Add 1023 before dividing (with truncation) by 1024,
		# so that the net effect is to round the number of
		# bytes up to the next whole number of kbytes.
		$max_rss_kbytes_bi->badd(1023);
		$max_rss_kbytes_bi->bdiv(1024);
		$max_rss_kbytes = sprintf "%s", $max_rss_kbytes_bi;
	    } elsif (/^\s*Per core CPU utilization \((\d+) cores\): (.*)$/) {
		($num_cpus, $usage_per_cpu) = ($1, $2);
	    } elsif (
		/^\s*number of times rss polled=\d+, avg of \d+(\.\d+)? times per second\s*$/ ||
		/^\s*time between consecutive polls \(msec\): min=\d+(\.\d+)? max=\d+(\.\d+)?\s*$/ ||
		/^\s*Max RSS observed \d+(\.\d+)? sec after start time\s*$/ ||
		/^\s*A call to task_info\(\) returned an error\.  error_time - end_time = -?\d+(\.\d+)? sec\.  This may mean the maximum resident set size measurement above is too low\.\s*$/)
	    {
		# Ignore these lines, but don't treat them as
		# unrecognized lines.
	    } else {
		if (! /^\s*$/) {
		    $unrecognized_cmd_stderr_output .= ($_ . "\n");
		}
	    }
	} else {
	    # This is a line of output from the program, most likely
	    # one printed to stderr if stdout has been redirected.
	    if (! /^\s*$/) {
		$unrecognized_cmd_stderr_output .= ($_ . "\n");
	    }
	}
    }
} elsif ($os eq 'GNU/Linux') {
    $cmd_exit_status = $child_exit_status;
    my $found_user = 0;
    while (<CATCHERR>) {
	chomp;
	if (/^\s*User time \(seconds\):\s*(.*)\s*$/) {
	    $user_sec = $1;
	    $found_user = 1;
        } elsif (/^\s*Command being timed:.*$/ ||
                 /^\s*Percent of CPU this job got: \d+%\s*$/ ||
                 /^\s*Average shared text size \(kbytes\): \d+\s*$/ ||
                 /^\s*Average unshared data size \(kbytes\): \d+\s*$/ ||
                 /^\s*Average stack size \(kbytes\): \d+\s*$/ ||
                 /^\s*Average total size \(kbytes\): \d+\s*$/ ||
                 /^\s*Average resident set size \(kbytes\): \d+\s*$/ ||
                 /^\s*Major \(requiring I\/O\) page faults: \d+\s*$/ ||
                 /^\s*Minor \(reclaiming a frame\) page faults: \d+\s*$/ ||
                 /^\s*Voluntary context switches: \d+\s*$/ ||
                 /^\s*Involuntary context switches: \d+\s*$/ ||
                 /^\s*Swaps: \d+\s*$/ ||
                 /^\s*File system inputs: \d+\s*$/ ||
                 /^\s*File system outputs: \d+\s*$/ ||
                 /^\s*Socket messages sent: \d+\s*$/ ||
                 /^\s*Socket messages received: \d+\s*$/ ||
                 /^\s*Signals delivered: \d+\s*$/ ||
                 /^\s*Page size \(bytes\): \d+\s*$/ ||
                 /^\s*Exit status: \d+\s*$/
                )
        {
            # Ignore these lines, but don't treat them as unrecognized
            # lines.
	} elsif (/^\s*Dumping CPU usage by sampling running threads \.\.\. done\.\s*$/) {
	    # Ignore this line if JVM profiling via sampling was
	    # enabled.
	} elsif ($found_user) {
            if (/^\s*System time \(seconds\):\s*(.*)\s*$/) {
		$sys_sec = $1;
            } elsif (/^\s*Elapsed \(wall clock\) time \(h:mm:ss or m:ss\):\s*(.*)\s*$/) {
                my $tmp = $1;
                if ($tmp =~ /^(\d+):(\d+):(\d+(\.\d+)?)$/) {
                    my ($h, $m, $s) = ($1, $2, $3);
                    $elapsed_sec = $h * 3600 + $m * 60 + $s;
                } elsif ($tmp =~ /^(\d+):(\d+(\.\d+)?)$/) {
                    my ($m, $s) = ($1, $2);
                    $elapsed_sec = $m * 60 + $s;
                } else {
                    die sprintf "Unrecognized Elapsed (wall clock) time format seen.  Aborting:\n%s", $tmp;
                }
	    } elsif (/^\s*Maximum resident set size \(kbytes\):\s*(\d+)\s*$/) {
                # There is a bug in GNU time version 1.7 that causes
                # the maximum resident set size reported to be 4 times
                # too large, at least when running on Linux.  See:
		#
                # http://www.mail-archive.com/help-gnu-utils@gnu.org/msg01371.html
		#
		# You can find out which version of GNU time you have
		# using this command:
		#
                #     /usr/bin/time -V

		# Use BigInt arithmetic, in case the integer is very
		# large.
		my $max_rss_kbytes_bi = Math::BigInt->new($1);
		$max_rss_kbytes_bi->bdiv(4);
		$max_rss_kbytes = sprintf "%s", $max_rss_kbytes_bi;
	    } else {
		if (! /^\s*$/) {
		    $unrecognized_cmd_stderr_output .= ($_ . "\n");
		}
	    }
	} else {
	    # This is a line of output from the program, most likely
	    # one printed to stderr if stdout has been redirected.
	    if (! /^\s*$/) {
		$unrecognized_cmd_stderr_output .= ($_ . "\n");
	    }
	}
    }
}
close(F);
if (($os eq 'GNU/Linux') || ($os eq 'Cygwin')) {
   $num_cpus = $#{$per_cpu_stats_start} + 1;
   if ($verbose) {
       printf STDERR "\$num_cpus=%s\n", $num_cpus;
   }
   $usage_per_cpu = '';
   my $i;
   for ($i = 0; $i < $num_cpus; $i++) {
       my $cpu_busy_percent =
	   cpu_busy_percent($per_cpu_stats_start->[$i]{idle},
			    $per_cpu_stats_end->[$i]{idle},
			    $per_cpu_stats_start->[$i]{total},
			    $per_cpu_stats_end->[$i]{total});
       my $cpu_busy_percent_without_bigints =
	   cpu_busy_percent_without_bigints($per_cpu_stats_start->[$i]{idle},
					    $per_cpu_stats_end->[$i]{idle},
					    $per_cpu_stats_start->[$i]{total},
					    $per_cpu_stats_end->[$i]{total});
       if ($cpu_busy_percent ne $cpu_busy_percent_without_bigints) {
	   die sprintf "For idle times %s %s and total times %s %s cpu_busy_percent() returned %s but cpu_busy_percent_without_bigints() returned %s\n",
	       $per_cpu_stats_start->[$i]{idle},
	       $per_cpu_stats_end->[$i]{idle},
	       $per_cpu_stats_start->[$i]{total},
	       $per_cpu_stats_end->[$i]{total},
	       $cpu_busy_percent,
	       $cpu_busy_percent_without_bigints;
       }
       $usage_per_cpu .= sprintf " %d%%", $cpu_busy_percent;
   }
   # Remove leading space.
   $usage_per_cpu = substr($usage_per_cpu, 1);
}
if ($unrecognized_cmd_stderr_output ne '') {
    printf STDERR "
The following lines were printed to stderr by the program while
being measured, and were not recognized as part of the output of the
program that is used for measurement:
        %s

%s
",
        $timemem_cmd, $unrecognized_cmd_stderr_output;
}
if ($verbose) {
    printf STDERR "\$elapsed_sec='%s'\n", $elapsed_sec;
    printf STDERR "\$user_sec='%s'\n", $user_sec;
    printf STDERR "\$sys_sec='%s'\n", $sys_sec;
    printf STDERR "\$max_rss_kbytes='%s'\n", $max_rss_kbytes;
}
if (!(defined($elapsed_sec) && defined($user_sec) &&
      defined($sys_sec) && defined($max_rss_kbytes) &&
      defined($num_cpus) && defined($usage_per_cpu) &&
      defined($cmd_exit_status)))
{
    printf STDERR "
One or more of the following values were not found in the output:
    elapsed, user, or kernel/system times
    maximum resident/working set size
    number of CPU cores, or their utilization
    command exit status
This is likely due to a change in the output format of the command
$timemem_cmd, and requires a corresponding change to $progname

The command line used was:
$cmd_to_run
";
    if ($os eq 'Cygwin') {
	printf STDERR "
Contents of batch file %s:
----------------------------------------
", $cmd_to_run;
	open(F,"$cmd_to_run") or die sprintf "Could not open file '%s' for reading.\n", $cmd_to_run;
	while (<F>) {
	    print STDERR $_;
	}
	close(F);
	printf STDERR
"----------------------------------------\n";
    }
    exit 1;
}

######################################################################
# If a check output command was given, run it to see if the output
# file's contents are good.
######################################################################

my $check_output_cmd_exit_status;
my $check_output_cmd_fail_info = '';
if (defined($output_file) && defined($check_output_cmd)) {
    $check_output_cmd =~ s/%o/$output_file/g;
    # TBD: Don't let anything sent to stdout of $check_output_cmd get
    # to our stdout, because it could mess up our XML file output.
    system($check_output_cmd);
    $check_output_cmd_exit_status = $?;
    if ($check_output_cmd_exit_status == -1) {
	printf STDERR "failed to execute cmd '%s': %s\n", $check_output_cmd, $!;
	exit 1;
    } elsif (($check_output_cmd_exit_status & 127) != 0) {
	$check_output_cmd_fail_info =
	    sprintf "check output cmd '%s' died with signal %d, %s coredump",
	        $check_output_cmd,
	        ($check_output_cmd_exit_status & 127),
	        ($check_output_cmd_exit_status & 128) ? 'with' : 'without';
    } else {
	my $child_exit_status = $check_output_cmd_exit_status >> 8;
	if ($child_exit_status != 0) {
	    $check_output_cmd_fail_info =
		sprintf "check output cmd '%s' exited with error status %d",
	            $check_output_cmd, $child_exit_status;
	}
    }
}
if ($check_output_cmd_fail_info ne '') {
    my ($copy_succeeded, $copy_info);
    ($save_dir_name, $copy_succeeded, $copy_info) =
	save_copy_of_file($save_dir_name, $output_file, 'output',
			  'cmd-output');
    $check_output_cmd_fail_info .= ("\n" . $copy_info);
    printf STDERR "%s\n", $check_output_cmd_fail_info;
}

# Note: If $check_output_cmd_exit_status is 0, then everything is fine.

# If it is not 0, then either it exited with a non-0 exit status, or
# it was stopped without exiting normally, e.g. via a signal.  No
# matter what non-0 value it is, we should conclude that we have not
# verified that the output is good.


######################################################################
# If --jvm-gc-stats option was given, read the GC log file and
# calculate summary GC performance stats.
######################################################################

my $gc_stats;
if (defined($gc_stats_type)) {
    $gc_stats = parse_jvm_gc_log($gc_stats_type, $gc_log_filename);
}


######################################################################
# Print the performance stats in the desired format.
######################################################################

# TBD: Add support so that --jvm-gc-stats works for the JRockit JVM.
# Currently only HotSpot works.  JRockit has different command line
# arguments to cause it to print GC details, and a different format
# for its GC messages that requires different parsing.

# TBD: (First part DONE) Make changes so that if a run has bad output,
# the bad output file is copied to a unique temporary file name that
# is reported on stderr and in the CSV/XML/stdout, so that the user
# can track down what the bad output was if they wish.  This temporary
# file should be created in the current working directory, or in a new
# temporary directory created that is *not* automatically erased when
# measureproc is done.  (Not done yet) Make an option to disable this
# copying action.

# TBD: (First part DONE) Similarly, if a GC log file cannot be parsed,
# copy it to a temporary file that will not be erased when measureproc
# is done, and report the name of the copy on stderr and in the
# CSV/XML/stdout output.  (Not done yet) Make an option that disables
# this copying action.

# TBD: percent of cpu this job got while it ran

# TBD: Is there a way to find out how much total CPU time *all other
# processes* got while this process was running?  It would be nice to
# have some kind of automated verification that the overall system
# load due to other processes was very low while running benchmark
# programs.  For an OS running in a virtual machine like VMware
# Fusion, I don't think the "guest OS" can determine how busy the CPU
# is in the "host OS", but it should at least be able to find out
# whether other processes in the "guest OS" are using much CPU time.

# TBD:
#    description string for result summary:
#        normal completion, output correct
#        normal completion, output incorrect
#	completed with exception <name>
#        unknown type of completion, output incorrect
#        killed after taking too long

# TBD: Details about the JVM used, if one is being used.  See
# misc/jvm-ptr-size.clj for some leads on how to determine whether the
# JVM is 32-bit or 64-bit, which is a significant factor for run time
# performance and memory use that should be recorded.

# TBD: Details about the virtual machine being used, e.g. VMware
# Fusion or Parallels Desktop on a Mac, or other similar things.  This
# can make a significant difference for performance, and should be
# recorded.  This will probably require an explicit command line
# argument from the user to specify it, unless there is some kind of
# relatively simple method I can use to get the info automatically.

# TBD: Description of hardware, e.g. # of CPU cores, type, and clock
# speed of each.

# For Ubuntu Linux, some info is available in /proc/cpuinfo

# Mac OS X command to get CPU details:
# /usr/sbin/system_profiler -detailLevel full SPHardwareDataType

# Command to get OS details in a format more like in "About This Mac"
# menu item: sw_vers

# Other similar commands mentioned at:
# http://serverfault.com/questions/14981/getting-cpu-information-from-command-line-in-mac-os-x-server

if ($output_format_csv) {
    if ($print_csv_name_row) {
	my $field_names = [ "Benchmark name",
			    "Language implementation",
			    "Source file name",
			    "Command measured",
			    "Input file",
			    "Output file",
			    "Current working directory",
			    "Elapsed sec",
			    "User sec",
			    "System sec",
			    "Max RSS KiBytes",
			    "Start time",
			    "End time",
			    "Num CPU cores",
			    "Usage per CPU core",
			    "Exit status",
			    "Command used to check output",
			    "Exit status of command used to check output",
			    "Failure details of command used to check output",
			    "Failure details of parsing GC log",
			    "Number of GCs",
			    "Total memory GCed (KB)",
			    "Total GC time (sec)",
			    "Maximum total available memory (KB)",
			    "Maximum total allocated memory (KB)",
			    "Maximum total live memory (KB)",
			    "OS description" ];
	my $field_name;
	my $first = 1;
	foreach $field_name (@{$field_names}) {
	    if ($first) {
		$first = 0;
	    } else {
		printf $log ",";
	    }
	    printf $log "%s", csv_str($field_name);
	}
	printf $log "\n";
    }
    printf $log "%s", csv_str($benchmark_name);
    printf $log ",%s", csv_str($language_implementation_desc_str);
    printf $log ",%s", csv_str($source_file_name);
    printf $log ",%s", csv_str($cmd_to_time);
    printf $log ",%s", cvs_str(defined($input_file) ? $input_file : '');
    printf $log ",%s", cvs_str(defined($output_file) ? $output_file : '');
    printf $log ",%s", csv_str($cwd);
    printf $log ",%s", $elapsed_sec;
    printf $log ",%s", $user_sec;
    printf $log ",%s", $sys_sec;
    printf $log ",%s", $max_rss_kbytes;
    printf $log ",%s", csv_str($start_time);
    printf $log ",%s", csv_str($end_time);
    printf $log ",%s", $num_cpus;
    printf $log ",%s", csv_str($usage_per_cpu);
    printf $log ",%s", $cmd_exit_status;
    printf $log ",%s", csv_str(defined($check_output_cmd) ? $check_output_cmd
			       : '');
    printf $log ",%s", (defined($check_output_cmd_exit_status)
			? $check_output_cmd_exit_status : '');
    printf $log ",%s", $check_output_cmd_fail_info;
    printf $log ",%s", ((defined($gc_stats_type) &&
			 defined($gc_stats->{parse_gc_log_fail_info}))
			? $gc_stats->{parse_gc_log_fail_info} : '');
    printf $log ",%s", defined($gc_stats_type) ? $gc_stats->{num_gcs} : '';
    printf $log ",%s", defined($gc_stats_type) ? $gc_stats->{total_mem_collected_kb} : '';
    printf $log ",%s", defined($gc_stats_type) ? $gc_stats->{total_gc_time_sec} : '';
    printf $log ",%s", defined($gc_stats_type) ? $gc_stats->{max_total_avail_mem_kb} : '';
    printf $log ",%s", defined($gc_stats_type) ? $gc_stats->{max_total_allocated_mem_kb} : '';
    printf $log ",%s", defined($gc_stats_type) ? $gc_stats->{max_total_live_mem_kb} : '';
    printf $log ",%s", csv_str($os_full);
    printf $log "\n";

} elsif ($output_format_xml) {

    # Create a new document
    my $xmldoc = XML::LibXML::Document->new();

    # ... with root element having tag MeasurementList
    my $mlist = $xmldoc->createElement('MeasurementList');
    $xmldoc->setDocumentElement($mlist);

    # ... and that root element has a first child with tag Measurement
    my $measurement = $xmldoc->createElement('Measurement');
    $mlist->appendChild($measurement);
    
    # Now fill in the fields of that measurement
    my $tag_text_pairs = [];
    if ($benchmark_name ne '') {
	push @{$tag_text_pairs}, 'benchmark_name', $benchmark_name;
    }
    if ($language_implementation_desc_str ne '') {
	push @{$tag_text_pairs},
	    'language_implementation', $language_implementation_desc_str;
    }
    if ($source_file_name ne '') {
	push @{$tag_text_pairs}, 'source_file_name', $source_file_name;
    }
    push @{$tag_text_pairs}, 'command_measured', $cmd_to_time;
    push @{$tag_text_pairs}, 'input_file',
        defined($input_file) ? $input_file : '';
    push @{$tag_text_pairs}, 'output_file',
        defined($output_file) ? $output_file : '';
    push @{$tag_text_pairs}, 'current_working_directory', $cwd;
    push @{$tag_text_pairs}, 'elapsed_time_sec', $elapsed_sec;
    push @{$tag_text_pairs}, 'user_cpu_time_sec', $user_sec;
    push @{$tag_text_pairs}, 'system_cpu_time_sec', $sys_sec;
    push @{$tag_text_pairs}, 'maximum_resident_set_size_kibibytes',
        $max_rss_kbytes;
    push @{$tag_text_pairs}, 'start_time', $start_time;
    push @{$tag_text_pairs}, 'end_time', $end_time;
    push @{$tag_text_pairs}, 'number_of_cpu_cores', $num_cpus;
    push @{$tag_text_pairs}, 'cpu_usage_per_core', $usage_per_cpu;
    push @{$tag_text_pairs}, 'exit_status', $cmd_exit_status;
    if (defined($output_file) && defined($check_output_cmd)) {
	push @{$tag_text_pairs}, 'command_to_check_output', $check_output_cmd;
	push @{$tag_text_pairs}, 'exit_status_of_check_cmd',
	    $check_output_cmd_exit_status;
	if ($check_output_cmd_fail_info ne '') {
	    push @{$tag_text_pairs}, 'check_output_cmd_failure_details',
	        $check_output_cmd_fail_info;
	}
    }
    if (defined($gc_stats_type)) {
	if (defined($gc_stats->{parse_gc_log_fail_info})) {
	    push @{$tag_text_pairs}, 'parse_gc_log_failure_details', $gc_stats->{parse_gc_log_failure_details};
	} else {
	    push @{$tag_text_pairs}, 'number_of_gcs', $gc_stats->{num_gcs};
	    push @{$tag_text_pairs}, 'total_memory_gced_kb', $gc_stats->{total_mem_collected_kb};
	    push @{$tag_text_pairs}, 'total_gc_time_sec', $gc_stats->{total_gc_time_sec};
	    push @{$tag_text_pairs}, 'maximum_total_available_memory_kb',
	        $gc_stats->{max_total_avail_mem_kb};
	    push @{$tag_text_pairs}, 'maximum_total_allocated_memory_kb',
	        $gc_stats->{max_total_allocated_mem_kb};
	    push @{$tag_text_pairs}, 'maximum_total_live_memory_kb',
	        $gc_stats->{max_total_live_mem_kb};
	}
    }
    push @{$tag_text_pairs}, 'operating_system', $os_full;
    if (defined($jvm_info_hash)) {
	push @{$tag_text_pairs},
	    'jvm_info_full_cmd', $jvm_info_hash->{'jvm_info_full_cmd'};
	foreach my $property (@{$jvm_property_names}) {
	    if (defined($jvm_info_hash->{$property})) {
		my $tag = 'jvm_' . $property;
		$tag =~ s/\./_/g;
		push @{$tag_text_pairs}, $tag, $jvm_info_hash->{$property};
	    }
	}
    }

    libxml_add_children_to_elem($xmldoc, $measurement, $tag_text_pairs);

    # and finally print out the XML file.
    print $log $xmldoc->toString(1);

} else {

    if ($benchmark_name ne '') {
	printf $log "    Benchmark name            : %s\n", $benchmark_name;
    }
    if ($language_implementation_desc_str ne '') {
	printf $log "    Language implementation   : %s\n", $language_implementation_desc_str;
    }
    if ($source_file_name ne '') {
	printf $log "    Source file name          : %s\n", $source_file_name;
    }
    printf $log "    Command measured          : %s\n", $cmd_to_time;
    if (defined($input_file)) {
	printf $log "    Input file                : %s\n", $input_file;
    }
    if (defined($output_file)) {
	printf $log "    Output file               : %s\n", $output_file;
    }
    printf $log "    Current working directory : %s\n", $cwd;
    printf $log "    Elapsed time (sec)        : %s\n", $elapsed_sec;
    printf $log "    User CPU time (sec)       : %s\n", $user_sec;
    printf $log "    System CPU time (sec)     : %s\n", $sys_sec;
    printf $log "    Max resident set size (KB): %s\n", $max_rss_kbytes;
    printf $log "    Start time                : %s\n", $start_time;
    printf $log "    End time                  : %s\n", $end_time;
    printf $log "    Per core CPU usage (%d cores): %s\n", $num_cpus, $usage_per_cpu;
    printf $log "    Exit status               : %s\n", $cmd_exit_status;
    if (defined($output_file) && defined($check_output_cmd)) {
	printf $log "    Command to check output   : %s\n", $check_output_cmd;
	printf $log "    Exit status of check cmd  : %s\n", $check_output_cmd_exit_status;
	if ($check_output_cmd_fail_info ne '') {
	    printf $log "Failure details of command used to check output: %s\n",
	        $check_output_cmd_fail_info;
	}
    }
    if (defined($gc_stats_type)) {
	if (defined($gc_stats->{parse_gc_log_failure_details})) {
	    printf $log "    Failure details of parsing GC log: %s\n", $gc_stats->{parse_gc_log_failure_details};
	} else {
	    printf $log "    Number of GCs             : %s\n", $gc_stats->{num_gcs};
	    printf $log "    Total memory GCed (KB)    : %s\n",
	        $gc_stats->{total_mem_collected_kb};
	    printf $log "    Total GC time (sec)       : %s\n", $gc_stats->{total_gc_time_sec};
	    printf $log "    Maximum total available memory (KB): %s\n",
	        $gc_stats->{max_total_avail_mem_kb};
	    printf $log "    Maximum total allocated memory (KB): %s\n",
	        $gc_stats->{max_total_allocated_mem_kb};
	    printf $log "    Maximum total live memory (KB)     : %s\n",
	        $gc_stats->{max_total_live_mem_kb};
	}
    }
    printf $log "    OS description            : %s\n", $os_full;
    if (defined($jvm_info_hash)) {
	printf $log "    %-26s: %s\n",
	    'JVM info full command', $jvm_info_hash->{'jvm_info_full_cmd'};
	foreach my $property (@{$jvm_property_names}) {
	    if (defined($jvm_info_hash->{$property})) {
		my $desc = 'JVM ' . $property;
		printf $log "    %-26s: %s\n",
		    $desc, $jvm_info_hash->{$property};
	    }
	}
    }
}

exit 0;


# Referring to the "Specification" section of this Wikipedia page:

# http://en.wikipedia.org/wiki/Comma-separated_values

# especially the "Basic rules" part of that section, it appears to me
# that I should be able to take _any_ string I want to put in a CSV
# field, whether it has quotes, commas, semicolons, etc. or not, put
# enclose it in double quotes, and replace all double quotes within
# the string with two consecutive double quotes, and it should be
# valid.  If I'm misunderstanding that, then I should be able to fix
# it by modifying this function.

sub csv_str {
    my $str = shift;
    my $csv_str;

    $csv_str = $str;
    # Try to only put double-quotes around strings that need them.
    # Note that while strings containing spaces might not need double
    # quotes, I'll go ahead and be extra-safe by doing so.
    if ($csv_str =~ /,|"|\s|\n/) {
	$csv_str =~ s/"/""/g;
	return '"' . $csv_str . '"';
    }
    return $csv_str;
}


sub linux_get_cpu_usage {
    my $per_cpu_stats = [];
    my $total_cpu_stats = {};

    my $filename = '/proc/stat';
    open(F,"$filename") or die sprintf "Could not open file '%s' for reading.\n", $filename;
    my $line = <F>;
    if ($line =~ /^\s*cpu\s+(\d+) (\d+) (\d+) (\d+)/) {
	my ($user, $nice, $sys, $idle) = ($1, $2, $3, $4);
        $total_cpu_stats->{user} = $user;
        $total_cpu_stats->{nice} = $nice;
        $total_cpu_stats->{sys} = $sys;
        $total_cpu_stats->{idle} = $idle;
        $total_cpu_stats->{total} = add_big_ints([$user, $nice, $sys, $idle]);
        $total_cpu_stats->{frequency} = 100;
    } else {
        die sprintf "linux_get_cpu_usage: Expected cpu at beginning of line, but found the following line instead:\n%s", $line;
    }

    my $i = 0;
    while ($line = <F>) {
        #printf STDERR "\$i=%s \$line='%s'\n", $i, $line;
        if ($line =~ /^\s*cpu(\d+) (\d+) (\d+) (\d+) (\d+)/) {
            my ($cpu, $user, $nice, $sys, $idle) = ($1, $2, $3, $4, $5);
            my $one_cpu_stats = {};
            if ($i != $cpu) {
               die sprintf "linux_get_cpu_usage: Expected cpu%d at beginning of line, but found cpu%d instead.\n", $i, $cpu;
            }
            $one_cpu_stats->{user} = $user;
            $one_cpu_stats->{nice} = $nice;
            $one_cpu_stats->{sys} = $sys;
            $one_cpu_stats->{idle} = $idle;
	    $one_cpu_stats->{total} = add_big_ints([$user, $nice, $sys, $idle]);
            $one_cpu_stats->{frequency} = 100;
            $per_cpu_stats->[$i] = $one_cpu_stats;
            $i++;
        } else {
            last;
        }
    }
    close(F);
    return ($per_cpu_stats, $total_cpu_stats);
}


# Take a list of strings containing integers as an argument, where the
# strings can contain arbitrarily large integers.  Add them and return
# the sum as a string.

sub add_big_ints {
    my $nums = shift;

    my $str = shift @{$nums};
    my $bigint_sum = Math::BigInt->new($str);
    foreach $str (@{$nums}) {
	my $x = Math::BigInt->new($str);
	$bigint_sum->badd($x);
    }
    return sprintf "%s", $bigint_sum;
}


sub cpu_busy_percent {
    my $idle1 = shift;
    my $idle2 = shift;
    my $total1 = shift;
    my $total2 = shift;

    my $total1_bi = Math::BigInt->new($total1);
    my $total_bi = Math::BigInt->new($total2);
    $total_bi->bsub($total1_bi);
    if ($total_bi->is_zero()) {
	return "0";
    } else {
	my $idle1_bi = Math::BigInt->new($idle1);
	my $idle_bi = Math::BigInt->new($idle2);
	$idle_bi->bsub($idle1_bi);

	# Now calculate 100 - ((100 * $idle_bi) / $total_bi), rounded
	# to nearest whole number.  To do that, we will calculate
	# ((1000 * ($total_bi - $idle_bi)) / $total_bi), then do the
	# rounding manually ourselves.  I'm sure that Perl's
	# Math::BigInt package provides a more succinct way of doing
	# this, but this will give the correct answer.
        my $busy_bi = $idle_bi->copy();
        $busy_bi->bsub($total_bi);
        $busy_bi->bneg();
	$busy_bi->bmul(1000);
	$busy_bi->bdiv($total_bi);

	my $last_digit_bi = $busy_bi->copy();
	$last_digit_bi->bmod(10);
	my $cpu_busy_percent_bi = $busy_bi->copy();
	$cpu_busy_percent_bi->bdiv(10);
	if ($last_digit_bi->bcmp(5) >= 0) {   # i.e. ($last_digit_bi >= 5)
	    $cpu_busy_percent_bi->binc();
	}
	return sprintf "%s", $cpu_busy_percent_bi;
    }
}


sub cpu_busy_percent_without_bigints {
    my $idle1 = shift;
    my $idle2 = shift;
    my $total1 = shift;
    my $total2 = shift;

    my $total = ($total2 - $total1);
    my $cpu_busy_percent = 0;
    if ($total != 0) {
	my $idle = ($idle2 - $idle1);
	$cpu_busy_percent = sprintf "%d", (100.0 * (1.0 - (1.0 * $idle) / $total)) + 0.5;
    }
    return sprintf "%d", $cpu_busy_percent;
}


sub time_cmd_location {
    my $os = shift;
    my $install_dir = shift;

    my $timemem_cmd;

    if ($os eq 'Cygwin') {
	$timemem_cmd = $install_dir . "/timemem";
	$timemem_cmd = `cygpath -w "$timemem_cmd"`;
	chomp $timemem_cmd;
    } elsif ($os eq 'Darwin') {
	$timemem_cmd = $install_dir . "/timemem-darwin";
    } elsif ($os eq 'GNU/Linux') {
	$timemem_cmd = "/usr/bin/time -v";
    } else {
	printf STDERR "Unknown OS string '%s'.  Only 'Cygwin', 'Darwin', and 'GNU/Linux' are supported.  Aborting.", $os;
	exit 1;
    }
    return $timemem_cmd;
}


sub libxml_add_children_to_elem {
    my $xmldoc = shift;
    my $elem = shift;
    my $tag_text_pairs = shift;

    my $n = $#{$tag_text_pairs};
    my $i;
    for ($i = 0; $i < $n; $i += 2) {
	my $tag_str = $tag_text_pairs->[$i];
	my $text_str = $tag_text_pairs->[$i+1];
	my $child = $xmldoc->createElement($tag_str);
	my $text = XML::LibXML::Text->new($text_str);
	$child->appendChild($text);
	$elem->appendChild($child);
    }
}


sub parse_jvm_gc_log {
    my $gc_stats_type = shift;
    my $gc_log_filename = shift;

    # This works for $gc_stats_type eq 'hotspot'.  Add support for
    # 'jrockit'

    my $num_mem_increase_warnings = 0;
    my $max_mem_increase_warnings_to_print = 3;

    my $num_gcs = 0;
    my $total_mem_collected_kb = 0;
    my $total_gc_time_sec = 0;
    my $max_total_avail_mem_kb = 0;
    my $max_total_allocated_mem_kb = 0;
    my $max_total_live_mem_kb = 0;
    my $parse_gc_log_fail_info;

    open(FH, '<', $gc_log_filename)
	or die sprintf "Could not open file %s for reading", $gc_log_filename;
    # TBD: Handle error in attempting to open file or parse file more
    # cleanly, i.e. by continuing and printing results without GC
    # summary stats.
    my $linenum = 0;
    my $already_saved_copy_of_gc_log = 0;
    my $unparseable_lines = 0;
    my $max_unparseable_lines_to_print = 5;
    while (my $line = <FH>) {
	++$linenum;
	chomp $line;
	if ($line =~ /\r$/) {
	    chop $line;
	}
	if ($line =~
	    /^\s*\d+\.\d+:\s+\[(GC|GC--|Full GC) (\d+)K->(\d+)K\((\d+)K\), (\S+) secs\]\s*$/)
	{
	    my ($gc_type, $live_before_this_gc_kb, $live_after_this_gc_kb,
		$total_avail_space_kb, $gc_time) = ($1, $2, $3, $4, $5);
	    # Notes from this source:
	    # http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html
	    
	    # $live_before_this_gc_kb space consists of objects that
	    # are actually live, or they are dead but still referenced
	    # from a tenured generation object after a previous minor
	    # GC.
	    
	    # Similarly for $live_after_this_gc_kb
	    
	    # $total_avail_space_kb is the total available space, not
	    # counting the space in the permanent generation, which is
	    # the total heap minus one of the survivor spaces.
	    
	    ++$num_gcs;
	    my $mem_collected_this_gc_kb = ($live_before_this_gc_kb -
					    $live_after_this_gc_kb);
	    if ($mem_collected_this_gc_kb < 0) {
		$mem_collected_this_gc_kb = 0;
		if ($num_mem_increase_warnings < $max_mem_increase_warnings_to_print) {
		    printf STDERR "Warning: %s < %s in line %d of GC log file '%s': %s\n",
		        $live_before_this_gc_kb, $live_after_this_gc_kb,
		        $linenum, $gc_log_filename, $line;
		}
		++$num_mem_increase_warnings;
	    }
	    $total_mem_collected_kb += $mem_collected_this_gc_kb;
	    $total_gc_time_sec += $gc_time;
	    if ($total_avail_space_kb > $max_total_avail_mem_kb) {
		$max_total_avail_mem_kb = $total_avail_space_kb;
	    }
	    if ($live_before_this_gc_kb > $max_total_allocated_mem_kb) {
		$max_total_allocated_mem_kb = $live_before_this_gc_kb;
	    }
	    if ($gc_type eq 'GC--') {
		# I've seen several of these where the
		# $live_after_this_gc_kb number is larger than the
		# $live_before_this_gc_kb number, and the after number
		# is significantly larger than the after number of
		# other GCs.  Until I find out what these mean, I'm
		# going to leave such GC lines out of the calculation
		# of the $max_total_live_mem_kb.
	    } else {
		if ($live_after_this_gc_kb > $max_total_live_mem_kb) {
		    $max_total_live_mem_kb = $live_after_this_gc_kb;
		}
	    }
	} elsif ($line =~ /^\s*\[INFO \]\[memory \] \[[YO]C#\d+\] (\d+(\.\d+)?)-(\d+(\.\d+)?): ([YO]C) (\d+)KB->(\d+)KB \((\d+)KB\), (\d+(\.\d+)?) s, sum of pauses (\d+(\.\d+)?) ms, longest pause (\d+(\.\d+)?) ms\.\s*$/) {
	    # TBD: Try to make this case and the one above share
	    # common code, rather than duplicating it.
	    my ($gc_start_time_sec, $gc_end_time_sec, $gc_type,
		$live_before_this_gc_kb, $live_after_this_gc_kb,
		$total_avail_space_kb, $gc_time_sec,
		$gc_time_msec, $gc_longest_pause_time_msec) =
		($1, $3, $5, $6, $7, $8, $9, $11, $13);
	    ++$num_gcs;
	    my $mem_collected_this_gc_kb = ($live_before_this_gc_kb -
					    $live_after_this_gc_kb);
	    if ($mem_collected_this_gc_kb < 0) {
		$mem_collected_this_gc_kb = 0;
		if ($num_mem_increase_warnings < $max_mem_increase_warnings_to_print) {
		    printf STDERR "Warning: %s < %s in line %d of GC log file '%s': %s\n",
		        $live_before_this_gc_kb, $live_after_this_gc_kb,
		        $linenum, $gc_log_filename, $line;
		}
		++$num_mem_increase_warnings;
	    }
	    $total_mem_collected_kb += $mem_collected_this_gc_kb;
	    $total_gc_time_sec += ($gc_time_msec / 1000.0);
	    if ($total_avail_space_kb > $max_total_avail_mem_kb) {
		$max_total_avail_mem_kb = $total_avail_space_kb;
	    }
	    if ($live_before_this_gc_kb > $max_total_allocated_mem_kb) {
		$max_total_allocated_mem_kb = $live_before_this_gc_kb;
	    }
	    if ($live_after_this_gc_kb > $max_total_live_mem_kb) {
		$max_total_live_mem_kb = $live_after_this_gc_kb;
	    }

	    # Do consistency check on ($gc_end_time_sec -
	    # $gc_start_time_sec), which I think should be close to
	    # $gc_time_sec.
	    my $double_check_gc_time_sec =
		($gc_end_time_sec - $gc_start_time_sec);
	    my $max_error_allowed_sec = 0.0015;
	    if (abs($double_check_gc_time_sec - $gc_time_sec) >
		$max_error_allowed_sec)
	    {
		printf STDERR "Warning: GC start time %s and end time %s give duration %.3f which is more than %s different than the reported time %s in line %d of GC log file '%s': %s\n",
		    $gc_start_time_sec, $gc_end_time_sec,
		    $double_check_gc_time_sec, $max_error_allowed_sec,
		    $gc_time_sec,
		    $linenum, $gc_log_filename, $line;
	    }

	    # Do consistency check between values of $gc_time_sec and
	    # $gc_time_msec.  $gc_time_sec should be equal to
	    # $gc_time_msec, perhaps rounded off.
	    $double_check_gc_time_sec = ($gc_time_msec / 1000.0);
	    # I don't know why, but I've seen these values differ by
	    # more than merely rounding error.  For example, in this line:
	    #
	    # [INFO ][memory ] [OC#4] 9.586-10.564: OC 284932KB->273009KB (489092KB), 0.977 s, sum of pauses 964.737 ms, longest pause 964.737 ms.
	    $max_error_allowed_sec = 0.020;
	    if (abs($double_check_gc_time_sec - $gc_time_sec) >
		$max_error_allowed_sec)
	    {
		printf STDERR "Warning: GC duration in msec %s is more than %s different than the reported time %s in sec in line %d of GC log file '%s': %s\n",
		    $gc_time_msec, $max_error_allowed_sec, $gc_time_sec,
		    $linenum, $gc_log_filename, $line;
	    }

	    # Do consistency check between values of
	    # $gc_longest_pause_time_msec and $gc_time_msec.  I
	    # believe the former should always be at most the latter.
	    if ($gc_longest_pause_time_msec > $gc_time_msec) {
		printf STDERR "Warning: longest pause %s is longer than total pause time %s in line %d of GC log file '%s': %s\n",
		    $gc_longest_pause_time_msec, $gc_time_msec,
		    $linenum, $gc_log_filename, $line;
	    }
	} elsif ($line =~ /^\s*\d+\.\d+:\s+\[GC, (\S+) secs\]\s*$/) {
	    # I have seen the version of the JVM described below
	    # produce a line in its GC log file very occasionally, as
	    # in once in _several_ runs of a program that printed 6600
	    # lines of output to its GC log file.  I am going to
	    # assume that it means that the time taken for this
	    # particular GC is the value given after the "GC,", but I
	    # won't update any of the memory statistics when reading
	    # such a line.

	    # % uname -a
	    # Linux ubuntu 2.6.32-25-generic #45-Ubuntu SMP Sat Oct 16 19:48:22 UTC 2010 i686 GNU/Linux
	    # % java -server -version
	    # java version "1.6.0_22"
	    # Java(TM) SE Runtime Environment (build 1.6.0_22-b04)
	    # Java HotSpot(TM) Server VM (build 17.1-b03, mixed mode)
	    my $gc_time = $1;
	    ++$num_gcs;
	    $total_gc_time_sec += $gc_time;
	} elsif (
            ($line =~ /^\s*\[INFO \]\[memory \] GC mode: Garbage collection optimized for .+, strategy: .+\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] Heap size: \d+KB, maximal heap size: \d+KB, nursery size: \d+KB\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] <start>-<end>: <type> <before>KB-><after>KB \(<heap>KB\), <time> ms, sum of pauses <pause> ms\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] <start>  - start time of collection \(seconds since jvm start\)\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] <type>   - OC \(old collection\) or YC \(young collection\)\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] <end>    - end time of collection \(seconds since jvm start\)\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] <before> - memory used by objects before collection \(KB\)\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] <after>  - memory used by objects after collection \(KB\)\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] <heap>   - size of heap after collection \(KB\)\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] <time>   - total time of collection \(milliseconds\)\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] <pause>  - total sum of pauses during collection \(milliseconds\)\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \]            Run with -Xverbose:gcpause to see individual phases\.\s*$/) ||
            ($line =~ /^\s*\[INFO \]\[memory \] Running on hypervisor Unknown \(but probably running on a hypervisor\)\s*$/)
	    )
	{
	    # Ignore these boilerplate header lines out of the JRockit JVM
	} elsif ($line =~ /^\s*\[ERROR\].*$/) {
	    my $err_msg = sprintf "Error: Found ERROR at line %d of GC log file '%s': %s",
	        $linenum, $gc_log_filename, $line;
	    if (! $already_saved_copy_of_gc_log) {
		# TBD: Avoid duplicating code here with the
		# $unparseable_lines case below.
		my ($copy_succeeded, $copy_info);
		($save_dir_name, $copy_succeeded, $copy_info) =
		    save_copy_of_file($save_dir_name, $gc_log_filename,
				      'GC log', 'gc-log');
		$err_msg .= ("\n" . $copy_info);
		$parse_gc_log_fail_info = $err_msg;
		$already_saved_copy_of_gc_log = 1;
	    }
	    printf STDERR "%s\n", $err_msg;
	} else {
	    ++$unparseable_lines;
	    my $err_msg =
		sprintf "Could not parse line %d of GC log file %s: '%s'",
	            $linenum, $gc_log_filename, $line;
	    if (! $already_saved_copy_of_gc_log) {
		my ($copy_succeeded, $copy_info);
		($save_dir_name, $copy_succeeded, $copy_info) =
		    save_copy_of_file($save_dir_name, $gc_log_filename,
				      'GC log', 'gc-log');
		$err_msg .= ("\n" . $copy_info);
		$parse_gc_log_fail_info = $err_msg;
		$already_saved_copy_of_gc_log = 1;
	    }
	    if ($unparseable_lines <= $max_unparseable_lines_to_print) {
		printf STDERR "%s\n", $err_msg;
	    }
	}
    }
    close(FH);
    if ($unparseable_lines > $max_unparseable_lines_to_print) {
	printf STDERR "%d additional error messages about unparseable GC log file lines were suppressed.\n",
	    ($unparseable_lines - $max_unparseable_lines_to_print);
    }

    if ($num_mem_increase_warnings > $max_mem_increase_warnings_to_print) {
	printf STDERR "%d additional warnings about memory use increasing during GC suppressed.\n",
	    $num_mem_increase_warnings - $max_mem_increase_warnings_to_print;
    }

    my $gc_stats = {
	num_gcs => $num_gcs,
	total_mem_collected_kb => $total_mem_collected_kb,
	total_gc_time_sec => $total_gc_time_sec,
	max_total_avail_mem_kb => $max_total_avail_mem_kb,
	max_total_allocated_mem_kb => $max_total_allocated_mem_kb,
	max_total_live_mem_kb => $max_total_live_mem_kb
    };
    if (defined($parse_gc_log_fail_info)) {
	$gc_stats->{parse_gc_log_fail_info} = $parse_gc_log_fail_info;
    }
    return $gc_stats;
}


sub save_copy_of_file {
    my $save_dir_name = shift;
    my $filename_to_save = shift;
    my $file_desc = shift;
    my $save_file_base_name = shift;

    if (!defined($save_dir_name)) {
	$save_dir_name = tempdir( $progname . '-XXXXXX', DIR => '.',
				  CLEANUP => 0 );
	# TBD: Check whether tempdir() succeeded, and print an error
	# message if it didn't.
    }
    my ($fh, $copy_filename) = tempfile( $save_file_base_name . '-XXXXXX',
					 DIR => $save_dir_name );
    close($fh);
    my $copy_succeeded;
    my $copy_info;
    if (copy($filename_to_save, $copy_filename)) {
	$copy_succeeded = 1;
	$copy_info =
	    sprintf "Copy of %s file '%s' (length %d bytes) saved as '%s'",
	        $file_desc, $filename_to_save, -s $filename_to_save,
	        $copy_filename;
    } else {
	$copy_succeeded = 0;
	$copy_info =
	    sprintf "Attempted to copy %s file '%s' (length %d bytes) as '%s', but failed: %s",
	        $file_desc, $filename_to_save, -s $filename_to_save,
	        $copy_filename, $!;
    }
    return ($save_dir_name, $copy_succeeded, $copy_info);
}
